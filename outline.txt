Master's Thesis

- 1. Intro - background on parsing, grammars
  - Take from ICFP paper?
- 1a. Related work (more serious than ICFP)
- 1b. what's new here?
  - (parsing parse trees for completeness; idea of parametrizing on splitting oracles to make naive recursive descent parsing efficient; particular splitter derivations for various grammars)
- 2. Explanation of CFGs, recursive descent parsing, making it terminating, idea of splitting oracles
  - Take from ICFP paper
- 2a. Brute force splitter
  - Note that, for soundness and completeness, there is a trivial splitter: it returns a list of all numbers between 0 and the length of the string.  Because the parser terminates no matter what list it is given, and all valid splits are trivially in this list, this splitting "oracle" is enough to fill the hole.
- 3. soundness and completeness
  - Take from ICFP paper
- 4. dependently typed parser, parsing parse trees for completeness
  - Take from ICFP paper
- 5. explanation of fiat framework for refining splitters
  - Main ideas:
    - refinements that preserve correctness
    - start from non-determinstic version
    - rewrite rules
    - explain refinement notation (ask Ben for our standard notation?)
    - explain indexed representation change
- 6. fixed length nonterminals, parsing (ab)*; parsing #s; parsing #, ()
  - The splitting strategy: if all strings parsed by a given nonterminal are the same length, then we can always split the string when faced with that nonterminal.
  - Write down the grammars we want to handle.
  - We can compute the length reflectively.  Here is the algorithm.  <Coq code here>
  - We relate the length to the parse trees by a few correctness criteria.
    - Note that we need to use only well-founded recursion.
  - Reflective determination of length and validity
  - Because it's never suboptimal to apply this rule (explain), we do it automatically, along with the indexed representation change (explain)
  - Example: Parse "abab"; parse "((123))"
- 7. disjoint items, parsing #, +
  - Explain strategy, same as above
- 8. table of next binary operation at the current level, parsing #, +, ()
  - Describe table building, table correctness
  - Example: parsing "(1+2)+3"
    - The generated table is
      "5, 1, 0, -, -, 0 .
        , 4, 3, 2, 1
      "
- (Optional: Showing that parser has "reasonable" performance on grammars with non-brute-force splitter (by using arrays and native strings))
- (Really Optional: building parse trees, not just recognizers)
- 9. Future work
  - JavaScript, performance