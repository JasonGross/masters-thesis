\chapter{Completeness and Soundness}
    Parsers come in a number of flavors.  The simplest flavor is the \emph{recognizer}, which simply says whether or not there exists a parse tree of a given string for a given nonterminal; it returns Booleans.  There is also a richer flavor of parser that returns inhabitants of \typeoption{\indname{ParseTree}}.

    For any recognizer \oftype{\fname{has\_parse}}{\Nonterminal\space\typeto\space\String\space\typeto\space\Bool}, we may ask whether it is \emph{sound}, meaning that when it returns \true, there is always a parse tree; and \emph{complete}, meaning that when there is a parse tree, it always returns \true.  We may express these properties as theorems (alternatively, dependently typed functions) with the following type signatures:
    \begin{align*}
      \fname{has\_parse\_sound} & \oftypesep
      (\oftype{\farg{nt}}{\Nonterminal})
      \typeto (\oftype{\farg{s}}{\String}) \\
      & \typeto \fname{has\_parse}~\farg{nt}~\farg{s} = \true \\
      & \typeto \indname{ParseTreeOf}~\farg{nt}~\farg{s} \\
      \fname{has\_parse\_complete} & \oftypesep
      (\oftype{\farg{nt}}{\Nonterminal})
      \typeto (\oftype{\farg{s}}{\String}) \\
      & \typeto \indname{ParseTreeOf}~\farg{nt}~\farg{s} \\
      & \typeto \fname{has\_parse}~\farg{nt}~\farg{s} = \true
    \end{align*}

    For any parser
    $$\oftype{\fname{parse}}{\Nonterminal~\typeto~\String~\typeto~\typeoption{\indname{ParseTree}}},$$
    we may also ask whether it is sound and complete, leading to theorems with the following type signatures, using \proj1{\farg{p}} to denote the first projection of \farg{p}:
    \begin{align*}
      \fname{parse\_sound} & \oftypesep
      (\oftype{\farg{nt}}{\Nonterminal}) \\
      & \typeto (\oftype{\farg{s}}{\String}) \\
      & \typeto (\oftype{\farg{p}}{\indname{ParseTree}}) \\
      & \typeto \fname{parse}~\farg{nt}~\farg{s} = \Some{\farg{p}} \\
      & \typeto \proj1{\farg{p}} = (\farg{nt}, \farg{s}) \\
      \fname{parse\_complete} & \oftypesep
      (\oftype{\farg{nt}}{\Nonterminal}) \\
      & \typeto (\oftype{\farg{s}}{\String}) \\
      & \typeto \indname{ParseTreeOf}~\farg{nt}~\farg{s} \\
      & \typeto \fname{parse}~\farg{nt}~\farg{s} \neq \None \\
    \end{align*}

    Since we are programming in Coq, this separation into code and proof actually makes for more awkward type assignments.  We also have the option of folding the soundness and completeness conditions into the types of the code.  For instance, the following type captures the idea of a sound and complete parser returning parse trees, using the type constructor $+$ for disjoint union (i.e., sum or variant type):
    \begin{align*}
      \fname{parse} & \oftypesep
      (\oftype{\farg{nt}}{\Nonterminal}) \\
      & \typeto (\oftype{\farg{s}}{\String}) \\
      & \typeto \indname{ParseTreeOf}~\farg{nt}~\farg{s} + (\indname{ParseTreeOf}~\farg{nt}~\farg{s} \typeto \False)
    \end{align*}

    That is, given a nonterminal and a string, $\fname{parse}$ either returns a valid parse tree, or returns a \emph{proof} that the existence of any parse tree is \emph{contradictory} (i.e., implies $\False$, the empty type).  Our implementation follows this dependently typed style.  Our main goal in the project was to arrive at a $\fname{parse}$ function of just this type, generic in an arbitrary choice of context-free grammar, implemented and proven correct in an elegant way.
