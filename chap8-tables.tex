\chapter{Parsing well-parenthesized expressions}
% \begin{itemize} \item  Goals:
%    \begin{itemize} \item  Hope to show that nontrivial splitting strategies are reasonably expressible, and reusable 
%    \item  Demo the main interesting splitting strategy 
%      \begin{itemize} \item  Explain how it can be used 
%      \item  Explain the ideas behind the table 
%      \item  Explain the way it's implemented \end{itemize} \end{itemize}
%  
\section{At a Glance}
  We finally get to a grammar that requires a non-trivial splitting strategy.  In this section, we describe how to parse strings for a grammar that accepts arithmetical expressions involving numbers, pluses, and well-balanced parentheses.  More generally, this strategy handles any binary operation with guarded brackets.
  
\section{Grammars we can parse}
  Consider the following two grammars, with \nt{digit} denoting the nonterminal that accepts any single decimal digit.
  
  Parenthesized addition:
  \todoask{Should I write these as inference rules, or as standard CFG presentations?}
  \begin{center}
    \AxiomC{$s$ $\in$ $\epsilon$}
    \RightLabel{\scriptsize(\nt{number?-$\epsilon$})}
    \UnaryInfC{$s$ $\in$ \nt{number?}}
  \DisplayProof\qquad
    \AxiomC{$s$ $\in$ \nt{number}}
    \RightLabel{\scriptsize(\nt{number?})}
    \UnaryInfC{$s$ $\in$ \nt{number?}}
  \DisplayProof\qquad
  \end{center}
  \begin{center}
    \AxiomC{$s_0$ $\in$ \nt{digit}}
    \AxiomC{$s_1$ $\in$ \nt{number?}}
    \RightLabel{\scriptsize(\nt{number})}
    \BinaryInfC{\strcat{$s_0$}{$s_1$} $\in$ \nt{number}}
  \DisplayProof
  \end{center}
  \begin{center}
    \AxiomC{$s_0$ $\in$ \terminal{(}}
    \AxiomC{$s_1$ $\in$ \nt{expr}}
    \AxiomC{$s_2$ $\in$ \terminal{)}}
    \RightLabel{\scriptsize(\nt{pexpr})}
    \TrinaryInfC{$s$ $\in$ \nt{pexpr}}
  \DisplayProof
  \end{center}
  \begin{center}
    \AxiomC{$s$ $\in$ \nt{number}}
    \RightLabel{\scriptsize(\nt{expr-number})}
    \UnaryInfC{$s$ $\in$ \nt{expr}}
  \DisplayProof\qquad
    \AxiomC{$s_0$ $\in$ \nt{pexpr}}
    \AxiomC{$s_1$ $\in$ \nt{+expr}}
    \RightLabel{\scriptsize(\nt{expr-pxpr})}
    \BinaryInfC{$s$ $\in$ \nt{expr}}
  \DisplayProof
  \end{center}
  \begin{center}
    \AxiomC{$s$ $\in$ $\epsilon$}
    \RightLabel{\scriptsize($\epsilon$-\nt{+expr})}
    \UnaryInfC{$s$ $\in$ \nt{+expr}}
  \DisplayProof\qquad
    \AxiomC{$s_0$ $\in$ \terminal{+}}
    \AxiomC{$s_1$ $\in$ \nt{expr}}
    \RightLabel{\scriptsize(\nt{+expr})}
    \BinaryInfC{\strcat{$s_0$}{$s_1$} $\in$ \nt{+expr}}
  \DisplayProof
  \end{center}
  
  \todo{Pick one of these}
  
  Or, in the standard presentation:
  \begin{align*}
    \nt{expr} & \Coloneqq \nt{number}~|~\nt{pexpr}~\nt{+expr} \\
    \nt{+expr} & \Coloneqq \epsilon~|~\terminal{+}~\nt{expr} \\
    \nt{pexpr} & \Coloneqq \terminal{(}~\nt{expr}~\terminal{)} \\
    \nt{number} & \Coloneqq \nt{digit}~\nt{number?} \\
    \nt{number?} & \Coloneqq \epsilon~|~\nt{number} \\
    \nt{digit} & \Coloneqq \terminal{0}~|~\terminal{1}~|~\terminal{2}~|~\terminal{3}~|~\terminal{4}~|~\terminal{5}~|~\terminal{6}~|~\terminal{7}~|~\terminal{8}~|~\terminal{9}
  \end{align*}
  
  We have carefully constructed this grammar so that the first character of the string suffices to uniquely determine which rule of any given nonterminal to apply.
  
  S-expressions are a notation for nested space-separated lists.  By replacing \nt{digit} with a nonterminal that accepts any symbol in a given set, which must not contain either of the brackets, nor whitespace, and replacing \terminal{+} with a space character \terminal{\ }, we get a grammar for S-expressions:
  \begin{align*}
    \nt{expr} & \Coloneqq \nt{atom}~|~\nt{pexpr}~\nt{sexpr} \\
    \nt{sexpr} & \Coloneqq \epsilon~|~\nt{whitespace}~\nt{expr} \\
    \nt{pexpr} & \Coloneqq \terminal{(}~\nt{expr}~\terminal{)} \\
    \nt{atom} & \Coloneqq \nt{symbol}~\nt{atom?} \\
    \nt{atom?} & \Coloneqq \epsilon~|~\nt{atom} \\
    \nt{whitespace} & \Coloneqq \nt{whitespace-char}~\nt{whitespace?} \\
    \nt{whitespace?} & \Coloneqq \epsilon~|~\nt{whitespace} \\
    \nt{whitespace-char} & \Coloneqq \terminal{\ }~|~\terminal{\textbackslash n}~|~\terminal{\textbackslash t}~|~\terminal{\textbackslash r}
  \end{align*}
  
\section{The Splitting Strategy}
  \subsection{The Main Idea}
    The only rule not already handled is the rule that says that a \nt{pexpr}~\nt{+expr} is an \nt{expr}.  The key insight here is that, to know where to split, we need to know where the next \terminal{+} at the current level of parenthetization is.  If we can compute an appropriate lookup table in time linear in the length of the string, then our splitter overall with be linear.
    
  \subsection{Building the Lookup Table}
    We build the table by reading the string from right to left, storing for each character the location of the next \terminal{+} at the current level of parenthetization.  To compute this location we keep a list of the location of next \terminal{+} at every level of parenthetization.  For example, for the string ``((1+2)+3)+4'', we have the following lists at each point in the string:
    \todo{Insert computation here}
      \begin{itemize} \item  The generated table is  \\
          "5, 1, 0, -, -, 0 .
            , 4, 3, 2, 1
          "
    \end{itemize}
    
  \subsection{The Code}
    \todo{Insert Haskell-like code here}
 
    Optimization: Compute based on original string, lookup based on indices, don't need to compute substrings.
  \subsection{The Correctness Proof}
    To use this as a refinement rule, we need to prove it complete.  To do this, we prove \todo{explain correctness criterion and insert relation of paren-balanced-hiding on a string to properties of grammar.}

 

\begin{verbatim}
Section IndexedImpl.

  Lemma ComputationalSplitter'
  : FullySharpened (string_spec plus_expr_grammar).
  Proof.
    start honing parser using indexed representation.

    hone method "splits".
    {
      simplify parser splitter.
      setoid_rewrite refine_binop_table; [ presimpl_after_refine_binop_table | reflexivity.. ].
      simpl.
      finish honing parser method.
    }

    FullySharpenEachMethodWithoutDelegation.
    extract delegate-free implementation.
    simpl; higher_order_reflexivityT.
  Defined.

  Lemma ComputationalSplitter
  : FullySharpened (string_spec plus_expr_grammar).
  Proof.
    let impl := (eval simpl in (projT1 ComputationalSplitter')) in
    refine (existT _ impl _).
    abstract (exact (projT2 ComputationalSplitter')).
  Defined.

End IndexedImpl.

\end{verbatim}

\begin{verbatim}
  Local Notation retT table
    := (refine {splits : list nat
               | split_list_is_complete
                   G (substring n m str)
                   (NonTerminal nt)
                   (Terminal ch :: its) splits}
               (ret [match List.nth n table None with
                       | Some idx => idx
                       | None => dummy_value
                     end])).

    Lemma refine_binop_table
          (predata := rdp_list_predata (G := G))
          (pdata := correct_open_close)
          (H_nt_hiding
           : match possible_valid_open_closes with
               | nil => false
               | _ => true
             end)
    : retT (list_of_next_bin_ops_opt str).
    Proof.
      unfold correct_open_close, possible_valid_open_closes in *.
      subst pdata.
      revert H_nt_hiding.
      generalize possible_open_closes.
      intro ls.
      induction ls; simpl.
      { intro; congruence. }
      { match goal with
          | [ |- context[if ?e then _ else nil] ] => destruct e eqn:?
        end.
        { simpl; intro.
          apply refine_binop_table'''; try assumption.
          apply ascii_lb; reflexivity. }
        { simpl; assumption. } }
    Qed.

    Definition bin_op_data_of (open close : Ascii.ascii)
    : paren_balanced_hiding_dataT Ascii.ascii
      := {| is_bin_op := ascii_beq ch;
            is_open := ascii_beq open;
            is_close := ascii_beq close |}.

    Definition maybe_open_closes {Char} (p : production Char)
    : list (Char * Char)
      := match hd None (map Some p), hd None (map Some (rev p)) with
           | Some (Terminal open), Some (Terminal close)
             => [(open, close)]
           | _, _ => nil
         end.

    Definition possible_open_closes
    : list (Ascii.ascii * Ascii.ascii)
      := fold_right
           (@app _)
           nil
           (map maybe_open_closes (Lookup G nt)).

    Definition possible_valid_open_closes
    : list (Ascii.ascii * Ascii.ascii)
      := fold_right
           (@app _)
           nil
           (map
              (fun oc
               => if paren_balanced_hiding_correctness_type (pdata := bin_op_data_of (fst oc) (snd oc)) G nt
                  then [oc]
                  else nil)
              possible_open_closes).

    Definition bin_op_data_of_maybe (oc : option (Ascii.ascii * Ascii.ascii))
    : paren_balanced_hiding_dataT Ascii.ascii
      := {| is_bin_op := ascii_beq ch;
            is_open ch' := match oc with
                             | Some oc' => ascii_beq (fst oc') ch'
                             | None => false
                           end;
            is_close ch' := match oc with
                              | Some oc' => ascii_beq (snd oc') ch'
                              | None => false
                            end |}.

    Definition correct_open_close
    : paren_balanced_hiding_dataT Ascii.ascii
      := bin_op_data_of_maybe
           (hd None (map Some possible_valid_open_closes)).

\end{verbatim}

\begin{verbatim}
    Definition paren_balanced'_step (ch : Char) (pbh_rest : nat -> bool) (start_level : nat)
    : bool
      := if is_bin_op ch
         then pbh_rest start_level
         else if is_open ch
              then pbh_rest (S start_level)
              else if is_close ch
                   then ((Compare_dec.gt_dec start_level 0)
                           && pbh_rest (pred start_level))%bool
                   else pbh_rest start_level.

    Global Instance paren_balanced'_step_Proper {ch}
    : Proper ((eq ==> eq) ==> eq ==> eq) (paren_balanced'_step ch).
    Proof.
      unfold paren_balanced'_step.
      repeat intro; subst.
      unfold respectful in *.
      edestruct Compare_dec.gt_dec; simpl;
      repeat match goal with
               | _ => reflexivity
               | [ |- context[if ?e then _ else _] ] => destruct e
               | [ H : _ |- _ ] => apply H
             end.
    Qed.

    Definition paren_balanced' (str : String) (start_level : nat)
    : bool
      := fold
           paren_balanced'_step
           Compare_dec.zerop
           str
           start_level.
    Definition paren_balanced (str : String) := paren_balanced' str 0.

    Definition paren_balanced_hiding'_step (ch : Char) (pbh_rest : nat -> bool) (start_level : nat)
    : bool
      := if is_bin_op ch
         then ((Compare_dec.gt_dec start_level 0)
                 && pbh_rest start_level)%bool
         else paren_balanced'_step ch pbh_rest start_level.

    Global Instance paren_balanced_hiding'_step_Proper {ch}
    : Proper ((eq ==> eq) ==> eq ==> eq) (paren_balanced_hiding'_step ch).
    Proof.
      unfold paren_balanced_hiding'_step.
      repeat intro; subst.
      edestruct Compare_dec.gt_dec; simpl;
      repeat match goal with
               | _ => reflexivity
               | [ H : _ |- _ ] => erewrite !H; reflexivity
             end.
    Qed.

    Definition paren_balanced_hiding' (str : String) (start_level : nat)
    : bool
      := fold
           paren_balanced_hiding'_step
           (Compare_dec.zerop)
           str
           start_level.

    Definition paren_balanced_hiding (str : String) := paren_balanced_hiding' str 0.

\end{verbatim}