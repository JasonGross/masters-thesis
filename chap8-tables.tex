\newcommand{\nullentry}{\texttt{\ensuremath{\emptyset}}}

\chapter{Parsing well-parenthesized expressions}\label{ch:tables}
% \begin{itemize} \item  Goals:
%    \begin{itemize} \item  Hope to show that nontrivial splitting strategies are reasonably expressible, and reusable 
%    \item  Demo the main interesting splitting strategy 
%      \begin{itemize} \item  Explain how it can be used 
%      \item  Explain the ideas behind the table 
%      \item  Explain the way it's implemented \end{itemize} \end{itemize}
%  
\section{At a Glance}
  We finally get to a grammar that requires a non-trivial splitting strategy.  In this section, we describe how to parse strings for a grammar that accepts arithmetical expressions involving numbers, pluses, and well-balanced parentheses.  More generally, this strategy handles any binary operation with guarded brackets.
  
\section{Grammars we can parse}
  Consider the following two grammars, with \nt{digit} denoting the nonterminal that accepts any single decimal digit.
  
  Parenthesized addition:
  \begin{align*}
    \nt{expr} & \Coloneqq \nt{pexpr}~\nt{+expr} \\
    \nt{+expr} & \Coloneqq \epsilon~|~\terminal{+}~\nt{expr} \\
    \nt{pexpr} & \Coloneqq \nt{number}~|~\terminal{(}~\nt{expr}~\terminal{)} \\
    \nt{number} & \Coloneqq \nt{digit}~\nt{number?} \\
    \nt{number?} & \Coloneqq \epsilon~|~\nt{number} \\
    \nt{digit} & \Coloneqq \terminal{0}~|~\terminal{1}~|~\terminal{2}~|~\terminal{3}~|~\terminal{4}~|~\terminal{5}~|~\terminal{6}~|~\terminal{7}~|~\terminal{8}~|~\terminal{9}
  \end{align*}
  
  We have carefully constructed this grammar so that the first character of the string suffices to uniquely determine which rule of any given nonterminal to apply.
  
  S-expressions are a notation for nested space-separated lists.  By replacing \nt{digit} with a nonterminal that accepts any symbol in a given set, which must not contain either of the brackets, nor whitespace, and replacing \terminal{+} with a space character \terminal{\ }, we get a grammar for S-expressions:
  \begin{align*}
    \nt{expr} & \Coloneqq \nt{pexpr}~\nt{sexpr} \\
    \nt{sexpr} & \Coloneqq \epsilon~|~\nt{whitespace}~\nt{expr} \\
    \nt{pexpr} & \Coloneqq \nt{atom}~|~\terminal{(}~\nt{expr}~\terminal{)} \\
    \nt{atom} & \Coloneqq \nt{symbol}~\nt{atom?} \\
    \nt{atom?} & \Coloneqq \epsilon~|~\nt{atom} \\
    \nt{whitespace} & \Coloneqq \nt{whitespace-char}~\nt{whitespace?} \\
    \nt{whitespace?} & \Coloneqq \epsilon~|~\nt{whitespace} \\
    \nt{whitespace-char} & \Coloneqq \terminal{\ }~|~\terminal{\textbackslash n}~|~\terminal{\textbackslash t}~|~\terminal{\textbackslash r}
  \end{align*}
  
\section{The Splitting Strategy}
  \subsection{The Main Idea}
    The only rule not already handled is the rule that says that a \nt{pexpr}~\nt{+expr} is an \nt{expr}.  The key insight here is that, to know where to split, we need to know where the next \terminal{+} at the current level of parenthesization is.  If we can compute an appropriate lookup table in time linear in the length of the string, then our splitter overall with be linear.
    
  \subsection{Building the Lookup Table}
    We build the table by reading the string from right to left, storing for each character the location of the next \terminal{+} at the current level of parenthesization.  To compute this location we keep a list of the location of next \terminal{+} at every level of parenthesization.
    
    \todoask{Should this example be set off with a \texttt{\textbackslash subsubsection} or a bold \textbf{Example.} or something?}
    Let's start with a very simple example, before moving to a more interesting one.  To parse \str{4+5}, we are primarily interested in the case where we are parsing something that is a number, or parenthesized on the left, followed by a \terminal{+}, followed by any expression.  For this item, we want to split the string right before the \terminal{+}, and say that the \str{4} can be parsed as a number (or parenthesized expression), and that the \str{+5} can be parsed as a \terminal{+} followed by an expression.
    
    To do this, we build a table that keeps track of the location of the next \terminal{+}, starting from the right of the string.  We will end up with the table:
    \begin{center}
    \tt
    \begin{tabular}{lccccc}
    \textrm{Table Entries: }&&1&0&\nullentry \\
    \textrm{String: } &\stropen&\strcolored{4}&\strcolored{+}&\strcolored{5}&\strclose
    \end{tabular}
    \end{center}
    At the \terminal{5}, there is no next \terminal{+}, and we are not parenthesized at all, so we record this as \nullentry.  At the \terminal{+}, we record that there is a \terminal{+} at the current level of parenthesization, with \texttt{0}.  Then, since the \terminal{4} is not a \terminal{+}, we increment the previous number, and store \texttt{1}.  This is the correct location to split the string: we parse 1 character as a \nt{number}, and the rest as \nt{+expr}.
    
    Now let's try a more complicated example: \str{(1+2)+3}.  We want to split this string into \str{(1+2)} and \str{+3}.  The above strategy is insufficient to do this; we need to keep track of the next \terminal{+} at all levels of parenthesization at each point.  We will end up with the following table, where the bottom-most element is the current level, and the ones above that are higher levels.  We use lines to indicate chains of numbers at the same level of parenthesization.    
    \[
    \xymatrix@C=0.5pc@R=0pc{
    &&&\texttt{4}\ar@{-}[r] &\texttt{3}\ar@{-}[r] &\texttt{2}\ar@{-}[r] &\texttt{1}\ar@{-}[ddr]\\
    \text{Table Entries:} \\
    &&\texttt{5}\ar@{-}[uur]&\texttt{1}\ar@{-}[r] &\texttt{0}\ar@{-}[r] &\nullentry\ar@{-}[r] &\nullentry&\texttt{0}\ar@{-}[r] &\nullentry\\
    \aswidthof{\text{String:}}{\text{Table Entries:}} & \stropen & \strcolored{(} & \strcolored{1} & \strcolored{+} & \strcolored{2} & \strcolored{)} & \strcolored{+} & \strcolored{3} & \strclose
    }
    \]    
    We again start from the right.  Since there are no \terminal{+}s that we have seen, we store the singleton list \valuelist{\nullentry}, indicating that we know about only the current level of parenthesization, and that there is no \terminal{+} to the right.  At the \terminal{+} before the \str{3}, we store the singleton list \valuelist{0}, indicating that the current character is a \terminal{+}, and we only know about one level of parenthesization.  At the \terminal{)}, we increment the counter for \terminal{+}, but we also now know about a new level of parenthesization.  So we store the two element list \valuelist{\nullentry, 1}.  At the \terminal{3}, we increment all numbers, storing \valuelist{\nullentry, 2}.  At the \terminal{+} before the \str{2}, we store \texttt{0} at the current level, and increment higher levels, storing \valuelist{0, 3}.  At the \terminal{1}, we simply increment all numbers, storing \valuelist{1, 4}.  Finally, at the \terminal{(}, we pop a level of parenthesization, and increment the remaining numbers, storing \valuelist{5}.  This is correct; we have 5 characters in the first string, and when we go to split \str{1+2} into \str{1} and \str{+2}, we have the list \valuelist{1, 4}, and the first string does indeed contain 1 character.
    
    As an optimization, we can drop all but the first element of each list once we're done computing, and, in fact, can do this as we construct the table.  However, for correctness, it is easier to reason about a list located at each location.
    
    
  \subsection{Table Correctness}
    What is the correctness condition on this table?  The correctness condition Fiat gives us is that the splits we compute must be the only ones that give rise to valid parses.  This is hard to reason about directly, so we use an intermediate correctness condition: for any cell of the table \todoask{IS MEANING OF CELL OBVIOUS?}, if it is empty (is \nullentry, or does not exist at all), then there must not be a well-parenthesized fragment of the string starting at that point and ending with a \terminal{+}, which closes the appropriate number of parentheses for this level of parenthesization. \todo{FIXME, THIS PREVIOUS SENTENCE SEEMS LIKE A CONFUSING EXPLANATION} \todoask{Any suggestions?} If the cell points to a given location, then that location must contain a \terminal{+}, and the fragment of the string starting at the current location and going up to but not including the \terminal{+}, must not contain any \terminal{+}s which are ``exposed''.  \todoask{THIS ALSO SEEMS CONFUSING.  Ideas?  Should I put code/math first?}
    
    More formally, we can define a notation of paren-balanced and paren-balanced-hiding-\terminal{+}.  Say that a string is paren-balanced at level $n$ if it closes exactly $n$ more parentheses than it opens, and there is no point at which it has closed more than n more parentheses than it has opened.  So the string \str{1+2)} is paren-balanced at level 1 (because it closes 1 more parenthesis than it opens), and the string \str{1+2)+(3} is not paren balanced at any level (though the string \str{1+2)+(3)} is paren-balanced at level 1).  A string is paren-balanced-hiding-\terminal{+} at level $n$ if it is paren-balanced at level $n$, and, at any point at which there is a \terminal{+}, at most $n-1$ more parentheses have been closed than opened.  So \str{(1+2)} is paren-balanced-hiding-\terminal{+} at level 0, and \str{(1+2))} is paren-balanced-hiding-\terminal{+} at level 1, and \str{(1+2)+3} is not paren-balanced-hiding-\terminal{+} at any level, though it is paren-balanced at level 0.  \todoask{THIS IS VERBOSE.  MAYBE I SHOULD START WITH CODE?}
    
    Then, the formal correctness condition is that if a cell at parenthesis level $n$ points to a location $\ell$, then the string from the cell up to but not including $\ell$ must be paren-balanced-hiding-\terminal{+} at level $n$, and the character at location $\ell$ must be a \terminal{+}.  If the cell is empty, then the string up to but not including any subsequent \terminal{+} must not be paren-balanced at level $n$.
    
    The table computed by the algorithm given above satisfies this correctness condition, and this correctness condition implies that the splitting locations given by the table are the only ones that produce valid parse trees; there is a unique table satisfying this correctness condition (because it picks out the \emph{first} \terminal{+} at the relevant level), and any split location which is not appropriately paren-balanced/paren-balanced-hiding results in no parse tree.  \todoask{THIS SEEMS REPETITIVE?}
  
  \subsection{Diving into Refinement Code}
    \todo{Check the following assumptions: that the reader has seen:
    \begin{itemize}
    \item what Fiat goals look like
    \item what the initial representation change to the indexed representation looks like
    \item the general structure of remaining splitter goals
    \end{itemize}
    }
    
    \todo{Remove me.  GOALS: rule is non-trivial, but use should be trivial.  pieces to making it trivial: no representation change, automatic discovery of binary operation and brackets, reflective side-conditions}
    
    Although the rule itself is non-trivial, our goal is to make using this rule as trivial as possible; we now explain how this refinement rule requires only one line of code to use (modulo long tactic names):
\begin{verbatim}
  setoid_rewrite refine_binop_table;
  [ presimpl_after_refine_binop_table | reflexivity.. ].
\end{verbatim}
    \todoask{How much explanation at this point?  Mention that \tactic{presimpl\ldots} only unfolds things?}
    
    There are three components to making a rule that can be used with a one-liner: not requiring a change of representation; reflective computation of the side-conditions, allowing them all to be discharged with \tacREFLEXIVITY; and automatic discovery of any arguments to the rule.  We cover each of these separately.
    
    \subsubsection{Doing Without a New Representation}
      Recall from \todo{secref} that the first step in any parser/splitter \todo{decide on which one to use} is to use an indexed representation of strings, where splitting a string only involves updating the indices into the original string, as well as taking care of all of the straightforward grammar rules.  Naively, we'd need to store a fresh table every time we split the string.
      
      How do we get around computing a new table on splits?  We pull the same trick here that we pulled on strings; we refer only to the table that is built from the initial string, and describe the correctness condition on the table in terms of arbitrary substrings of that string.
      
      Fiat presents us with a goal involving a statement of the form ``non-deterministically pick a list of splitting locations that is complete for the substring of \farg{str} starting at \farg{n} and ending at \farg{m}, for the rule \nt{pexpr}\nt{+expr}.''  In code form, this is:
\begin{verbatim}
{splits : list nat
| split_list_is_complete
    G
    (substring n m str)
    (NonTerminal nt)
    (Terminal ch :: its)
    splits}
\end{verbatim}
    \todoask{How much should I say about this code?  For example, the current Coq code doesn't line up perfectly with the explanation; the code only handles the case where the rule is ``a nonterminal, followed by a terminal, followed by other things'', not the form presented above, where the nonterminal is hidden by one layer of indirection (to prevent backtracking).}
    
    The final refinement rule, which we use with \tactic{setoid\_rewrite}, says that this is refined by a lookup into a suitably defined \farg{table}:
\todo{Standardize notation for goals, or drop code}
\begin{verbatim}
refine {splits : list nat
       | split_list_is_complete
           G
           (substring n m str)
           (NonTerminal nt)
           (Terminal ch :: its)
           splits}
       (ret [match List.nth n table None with
               | Some idx => idx
               | None => dummy_value
             end])
\end{verbatim}

    By phrasing the rule in terms of \fname{substring}~\farg{n}~\farg{m}~\farg{str}, rather than in terms of an arbitrary string, the computation of the table is the same in every call to the splitter.  All that remains is to lift the computation outside of the recursive call to the parsing function during the extraction phase, which we plan to do soon. \todo{Section reference future work.  Add bit to future work.}
    
    Before moving on to the other components of making usage of this rule require only one line of code, we note that we make use of the essential property that removing characters from the end of the string doesn't add new locations where splitting could yield a valid parse; if a given location is the first \terminal{+} at the current level of parenthesization, this does not change when we remove characters from the end of the string.  \todoask{Should there be more content here?}
    
  \subsubsection{Discharging the Side-Conditions Trivially}
    To prove the correctness condition on the table, we need to know some things about the grammar that we are handling.  In particular, we need to know that if we are trying to parse a string as a rule analogous to \nt{pexpr}, then there can be no exposed \terminal{+} characters, and, furthermore, that every such parseable string has well-balanced parentheses.  To allow discharging the side conditions trivially, we define a function that computes whether or not this is the case for a given nonterminal in a given grammar.  We then prove that, whenever this function returns \true, valid tables yield complete lists of splitting locations.
    
    To make things simple, we approximate which grammars are valid; we require that every open parenthesis be closed in the same rule (rather than deeply nested in further nonterminals).  In Haskell-like pseudocode, the function we use to check validity of a grammar can be written as:
\begin{verbatim}
grammar-and-nonterminal-is-valid : Grammar -> NonTerminal -> Bool
grammar-and-nonterminal-is-valid G nt
  = fold (&&) paren-balanced-hiding G (G.(Lookup) nt)

pb' : Grammar -> Char -> Nat -> [Item] -> Bool
pb' G n []         = (n == 0)
pb' G n (NonTerminal nt :: s)
  = fold (&&) (pb' G 0) (G.(Lookup) nt) && pb' G n s
pb' G n ('(' :: s) = pb' G (n + 1) s
pb' G n (')' :: s) = n > 0 && pb' G (n - 1) s
pb' G n (_ :: s)   = pb' G n s

paren-balanced G = pb' G 0

pbh' : Grammar -> Char -> Nat -> [Item] -> Bool
pbh' G n []         = (n == 0)
pbh' G n (NonTerminal nt :: s)
  = fold (pbh' G 0) (G.(Lookup) nt) && pb' G n s
pbh' G n ('+' :: s) = n > 0 && pbh' G n s
pbh' G n ('(' :: s) = pbh' G (n + 1) s
pbh' G n (')' :: s) = n > 0 && pbh' G (n - 1) s
pbh' G n (_ :: s)   = pbh' G n s

paren-balanced-hiding G = pbh' G 0
\end{verbatim}    
    \todoask{Does this code need more explanation?}
    
    There is one subtlety here, that was swept under the rug in the above code: this computation might not terminate!  We could deal with this by memoizing this computation in much the same way that we memoized the parser to deal with potentially infinite parse trees.  Rather than dealing with the subtleties of figuring out what to do when we hit repeated nonterminals, we perform the computation in two steps.  First, we trace the algorithm above, building up a list of which nonterminals need to be paren-balanced, and which ones need to be paren-balanced-hiding.  Second, we fold the computation over these lists, replacing the recursive calls for nonterminals with list membership tests. \todoask{Does this need code?}
    
  \subsubsection{Automatic Discovery of Arguments}
    Throughout this chapter, we've been focusing on the arithmetic expression example.  However, the exact same rule can handle S-expressions, with just a bit of generalization.  There are two things to be computed: the binary operation, and the parenthesis characters.\footnote{Currently, our code requires the binary operation to be exposed as a terminal in the rule we are handling.  We plan on generalizing this to the grammars described in this chapter shortly.}
    
    We require that the first character of any string parsed by the nonterminal analogous to \nt{+expr} be uniquely determined; that character will be the binary operator; we can reuse the code from \autoref{ch:disjoint} to compute this character and ensure that it is unique.
    
    To find the parenthesis characters, we first compute a list of candidate character pairs: for each rule associated to the nonterminal analogous to \nt{pexpr}, we consider the pair of the first character and the last character (assuming both are terminals) to be a candidate pair.\footnote{Again, generalizing this to characters hidden by nested nonterminals should be straightforward.}  We then filter the list for characters which yield the conclusion that this rule is applicable to the grammar, according to the algorithm of the previous subsubsection.  We then require, as a side-condition, that the length of this list be positive.
    
%  \subsection{The Correctness Proof}
%    To use this as a refinement rule, we need to prove it complete.  To do this, we prove \todo{explain correctness criterion and insert relation of paren-balanced-hiding on a string to properties of grammar.}

% 
%
%\begin{verbatim}
%Section IndexedImpl.
%
%  Lemma ComputationalSplitter'
%  : FullySharpened (string_spec plus_expr_grammar).
%  Proof.
%    start honing parser using indexed representation.
%
%    hone method "splits".
%    {
%      simplify parser splitter.
%      setoid_rewrite refine_binop_table; [ presimpl_after_refine_binop_table | reflexivity.. ].
%      simpl.
%      finish honing parser method.
%    }
%
%    FullySharpenEachMethodWithoutDelegation.
%    extract delegate-free implementation.
%    simpl; higher_order_reflexivityT.
%  Defined.
%
%  Lemma ComputationalSplitter
%  : FullySharpened (string_spec plus_expr_grammar).
%  Proof.
%    let impl := (eval simpl in (projT1 ComputationalSplitter')) in
%    refine (existT _ impl _).
%    abstract (exact (projT2 ComputationalSplitter')).
%  Defined.
%
%End IndexedImpl.
%
%\end{verbatim}
%
%\begin{verbatim}
%  Local Notation retT table
%    := (refine {splits : list nat
%               | split_list_is_complete
%                   G (substring n m str)
%                   (NonTerminal nt)
%                   (Terminal ch :: its) splits}
%               (ret [match List.nth n table None with
%                       | Some idx => idx
%                       | None => dummy_value
%                     end])).
%
%    Lemma refine_binop_table
%          (predata := rdp_list_predata (G := G))
%          (pdata := correct_open_close)
%          (H_nt_hiding
%           : match possible_valid_open_closes with
%               | nil => false
%               | _ => true
%             end)
%    : retT (list_of_next_bin_ops_opt str).
%    Proof.
%      unfold correct_open_close, possible_valid_open_closes in *.
%      subst pdata.
%      revert H_nt_hiding.
%      generalize possible_open_closes.
%      intro ls.
%      induction ls; simpl.
%      { intro; congruence. }
%      { match goal with
%          | [ |- context[if ?e then _ else nil] ] => destruct e eqn:?
%        end.
%        { simpl; intro.
%          apply refine_binop_table'''; try assumption.
%          apply ascii_lb; reflexivity. }
%        { simpl; assumption. } }
%    Qed.
%
%    Definition bin_op_data_of (open close : Ascii.ascii)
%    : paren_balanced_hiding_dataT Ascii.ascii
%      := {| is_bin_op := ascii_beq ch;
%            is_open := ascii_beq open;
%            is_close := ascii_beq close |}.
%
%    Definition maybe_open_closes {Char} (p : production Char)
%    : list (Char * Char)
%      := match hd None (map Some p), hd None (map Some (rev p)) with
%           | Some (Terminal open), Some (Terminal close)
%             => [(open, close)]
%           | _, _ => nil
%         end.
%
%    Definition possible_open_closes
%    : list (Ascii.ascii * Ascii.ascii)
%      := fold_right
%           (@app _)
%           nil
%           (map maybe_open_closes (Lookup G nt)).
%
%    Definition possible_valid_open_closes
%    : list (Ascii.ascii * Ascii.ascii)
%      := fold_right
%           (@app _)
%           nil
%           (map
%              (fun oc
%               => if paren_balanced_hiding_correctness_type (pdata := bin_op_data_of (fst oc) (snd oc)) G nt
%                  then [oc]
%                  else nil)
%              possible_open_closes).
%
%    Definition bin_op_data_of_maybe (oc : option (Ascii.ascii * Ascii.ascii))
%    : paren_balanced_hiding_dataT Ascii.ascii
%      := {| is_bin_op := ascii_beq ch;
%            is_open ch' := match oc with
%                             | Some oc' => ascii_beq (fst oc') ch'
%                             | None => false
%                           end;
%            is_close ch' := match oc with
%                              | Some oc' => ascii_beq (snd oc') ch'
%                              | None => false
%                            end |}.
%
%    Definition correct_open_close
%    : paren_balanced_hiding_dataT Ascii.ascii
%      := bin_op_data_of_maybe
%           (hd None (map Some possible_valid_open_closes)).
%
%
%
%\end{verbatim}
%
%\begin{verbatim}
%    Definition paren_balanced'_step (ch : Char) (pbh_rest : nat -> bool) (start_level : nat)
%    : bool
%      := if is_bin_op ch
%         then pbh_rest start_level
%         else if is_open ch
%              then pbh_rest (S start_level)
%              else if is_close ch
%                   then ((Compare_dec.gt_dec start_level 0)
%                           && pbh_rest (pred start_level))%bool
%                   else pbh_rest start_level.
%
%    Global Instance paren_balanced'_step_Proper {ch}
%    : Proper ((eq ==> eq) ==> eq ==> eq) (paren_balanced'_step ch).
%    Proof.
%      unfold paren_balanced'_step.
%      repeat intro; subst.
%      unfold respectful in *.
%      edestruct Compare_dec.gt_dec; simpl;
%      repeat match goal with
%               | _ => reflexivity
%               | [ |- context[if ?e then _ else _] ] => destruct e
%               | [ H : _ |- _ ] => apply H
%             end.
%    Qed.
%
%    Definition paren_balanced' (str : String) (start_level : nat)
%    : bool
%      := fold
%           paren_balanced'_step
%           Compare_dec.zerop
%           str
%           start_level.
%    Definition paren_balanced (str : String) := paren_balanced' str 0.
%
%    Definition paren_balanced_hiding'_step (ch : Char) (pbh_rest : nat -> bool) (start_level : nat)
%    : bool
%      := if is_bin_op ch
%         then ((Compare_dec.gt_dec start_level 0)
%                 && pbh_rest start_level)%bool
%         else paren_balanced'_step ch pbh_rest start_level.
%
%    Global Instance paren_balanced_hiding'_step_Proper {ch}
%    : Proper ((eq ==> eq) ==> eq ==> eq) (paren_balanced_hiding'_step ch).
%    Proof.
%      unfold paren_balanced_hiding'_step.
%      repeat intro; subst.
%      edestruct Compare_dec.gt_dec; simpl;
%      repeat match goal with
%               | _ => reflexivity
%               | [ H : _ |- _ ] => erewrite !H; reflexivity
%             end.
%    Qed.
%
%    Definition paren_balanced_hiding' (str : String) (start_level : nat)
%    : bool
%      := fold
%           paren_balanced_hiding'_step
%           (Compare_dec.zerop)
%           str
%           start_level.
%
%    Definition paren_balanced_hiding (str : String) := paren_balanced_hiding' str 0.
%
%\end{verbatim}
%
%\begin{verbatim}
%  Definition cell_of_next_bin_ops_spec'' (level : nat) (cell : option nat) (str : String) offset idx
%    := (cell = Some idx
%        -> index_points_to_binop offset idx str
%           /\ paren_balanced_hiding' (take idx (drop offset str)) level)
%       /\ (cell = None
%           -> paren_balanced' (take idx (drop offset str)) level
%           -> index_not_points_to_binop offset idx str).
%
%  Definition list_of_next_bin_ops_spec'' (level : nat) (table : list (option nat)) (str : String) offset idx
%    := cell_of_next_bin_ops_spec'' level (nth offset table None) str offset idx.
%
%  Definition list_of_next_bin_ops_spec' (level : nat) (table : list (option nat)) (str : String)
%    := forall offset idx, list_of_next_bin_ops_spec'' level table str offset idx.
%
%  Definition list_of_next_bin_ops_spec
%    := list_of_next_bin_ops_spec' 0.
%
%
%
%  (** We build a version of paren-balanced-hiding to compute each cell
%      of the table. *)
%  (**
%<<
%pb' ch n "" = (n == 0)
%pb' ch n (ch :: s) = n > 0 && pb' ch n s
%pb' ch n ('(' :: s) = pb' ch (n + 1) s
%pb' ch n (')' :: s) = n > 0 && pb' ch (n - 1) s
%pb' ch n (_ :: s) = pb' ch n s
%
%pb = pb' '+' 0
%>>
%*)
%
%
%  Definition compute_next_bin_op'_step
%    := (fun ch next level
%        => if is_bin_op ch
%           then if Compare_dec.gt_dec level 0
%                then option_map S (next level)
%                else Some 0
%           else if is_open ch
%                then option_map S (next (S level))
%                else if is_close ch
%                     then if Compare_dec.gt_dec level 0
%                          then option_map S (next (pred level))
%                          else None
%                     else option_map S (next level)).
%
%  Definition compute_next_bin_op' (str : String) (level : nat)
%  : option nat
%    := fold
%         compute_next_bin_op'_step
%         (fun _ => None)
%         str
%         level.
%
%\end{verbatim}