\chapter{Parsing well-parenthesized expressions}
\section{At a Glance}
  We finally get to a grammar that requires a non-trivial splitting strategy.  In this section, we describe how to parse strings for a grammar that accepts arithmetical expressions involving numbers, pluses, and well-balanced parentheses.  More generally, this strategy handles any binary operation with guarded brackets.
  
\section{Grammars we can parse}
  Consider the following two grammars, with \nt{digit} denoting the nonterminal that accepts any single decimal digit.
  
  Parenthesized addition:
  \begin{center}
    \AxiomC{$s$ $\in$ \nt{digit}}
    \RightLabel{\scriptsize(\nt{number$_1$)}
    \UnaryInfC{$s$ $\in$ \nt{number}}
  \DisplayProof\qquad
    \AxiomC{$s_0$ $\in$ \nt{digit}}
    \AxiomC{$s_1$ $\in$ \nt{number}}
    \RightLabel{\scriptsize(\nt{number$_*$)}
    \BinaryInfC{\strcat{$s_0$}{$s_1$} $\in$ \nt{number}}
  \DisplayProof
  \end{center}
  \begin{center}
    \AxiomC{$s_0$ $\in$ \terminal{(}}
    \AxiomC{$s_1$ $\in$ \nt{expr}}
    \AxiomC{$s_2$ $\in$ \terminal{)}}
    \RightLabel{\scriptsize(\nt{pexpr})}
    \UnaryInfC{$s$ $\in$ \nt{pexpr}}
  \DisplayProof
  \end{center}
  \begin{center}
    \AxiomC{$s$ $\in$ \nt{number}}
    \RightLabel{\scriptsize(\nt{expr-number)}
    \UnaryInfC{$s$ $\in$ \nt{expr}}
  \DisplayProof\qquad
    \AxiomC{$s_0$ $\in$ \nt{pexpr}}
    \AxiomC{$s_1$ $\in$ \nt{+expr}}
    \RightLabel{\scriptsize(\nt{expr-pxpr)}
    \BinaryInfC{$s$ $\in$ \nt{expr}}
  \end{center}
  \begin{center}
    \AxiomC{$s$ $\in$ $\epsilon$}
    \RightLabel{\scriptsize($\epsilon$-\nt{+expr})}
    \UnaryInfC{$s$ $\in$ \nt{+expr}}
  \DisplayProof\qquad
    \AxiomC{$s_0$ $\in$ \terminal{+}}
    \AxiomC{$s_1$ $\in$ \nt{expr}}
    \RightLabel{\scriptsize(\nt{+expr})}
    \BinaryInfC{\strcat{$s_0$}{$s_1$} $\in$ \nt{+expr}}
  \DisplayProof
  \end{center}HERE
  \begin{itemize} \item  Goals:
    \begin{itemize} \item  Hope to show that nontrivial splitting strategies are reasonably expressible, and reusable 
    \item  Demo the main interesting splitting strategy 
      \begin{itemize} \item  Explain how it can be used 
      \item  Explain the ideas behind the table 
      \item  Explain the way it's implemented \end{itemize} \end{itemize}
  \item  {}[nontrivial] Example grammars we want to handle: \#, +, (); S-expressions
  \item  {}[nontrivial] Explain commonalities (balance, binops)
  \item  {}[idea] Lookup tables, in O(length)
    \begin{itemize} \item  The only new rule is when we have pexpr followed by +. 
    \item  The key insight here is that, to know where to split, we need to know where the next "+" at the current level of parenthetization is. 
    \item  Building the table 
      \begin{itemize} \item  explain rule, keep list of binops at all levels \end{itemize} 
    \item  Proving the table correct 
      \begin{itemize} \item  explain correctness criterion 
      \item  Relation of paren-balanced-hiding on a string to properties of grammar. \end{itemize} \end{itemize}
  \item  {}[explain implementation]
  \item  {}[impl detail] Optimization: Compute based on original string, lookup based on indices, don't need to compute substrings.
  \item  Example: parsing "(1+2)+3"
    \begin{itemize} \item  The generated table is  \\
      "5, 1, 0, -, -, 0 .
        , 4, 3, 2, 1
      "
\end{itemize} \end{itemize}