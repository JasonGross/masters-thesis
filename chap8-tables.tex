\chapter{Parsing well-parenthesized expressions}
% \begin{itemize} \item  Goals:
%    \begin{itemize} \item  Hope to show that nontrivial splitting strategies are reasonably expressible, and reusable 
%    \item  Demo the main interesting splitting strategy 
%      \begin{itemize} \item  Explain how it can be used 
%      \item  Explain the ideas behind the table 
%      \item  Explain the way it's implemented \end{itemize} \end{itemize}
%  
\section{At a Glance}
  We finally get to a grammar that requires a non-trivial splitting strategy.  In this section, we describe how to parse strings for a grammar that accepts arithmetical expressions involving numbers, pluses, and well-balanced parentheses.  More generally, this strategy handles any binary operation with guarded brackets.
  
\section{Grammars we can parse}
  Consider the following two grammars, with \nt{digit} denoting the nonterminal that accepts any single decimal digit.
  
  Parenthesized addition:
  \todoask{Should I write these as inference rules, or as standard CFG presentations?}
  \begin{center}
    \AxiomC{$s$ $\in$ $\epsilon$}
    \RightLabel{\scriptsize(\nt{number?-$\epsilon$})}
    \UnaryInfC{$s$ $\in$ \nt{number?}}
  \DisplayProof\qquad
    \AxiomC{$s$ $\in$ \nt{number}}
    \RightLabel{\scriptsize(\nt{number?})}
    \UnaryInfC{$s$ $\in$ \nt{number?}}
  \DisplayProof\qquad
  \end{center}
  \begin{center}
    \AxiomC{$s_0$ $\in$ \nt{digit}}
    \AxiomC{$s_1$ $\in$ \nt{number?}}
    \RightLabel{\scriptsize(\nt{number})}
    \BinaryInfC{\strcat{$s_0$}{$s_1$} $\in$ \nt{number}}
  \DisplayProof
  \end{center}
  \begin{center}
    \AxiomC{$s_0$ $\in$ \terminal{(}}
    \AxiomC{$s_1$ $\in$ \nt{expr}}
    \AxiomC{$s_2$ $\in$ \terminal{)}}
    \RightLabel{\scriptsize(\nt{pexpr})}
    \TrinaryInfC{$s$ $\in$ \nt{pexpr}}
  \DisplayProof
  \end{center}
  \begin{center}
    \AxiomC{$s$ $\in$ \nt{number}}
    \RightLabel{\scriptsize(\nt{expr-number})}
    \UnaryInfC{$s$ $\in$ \nt{expr}}
  \DisplayProof\qquad
    \AxiomC{$s_0$ $\in$ \nt{pexpr}}
    \AxiomC{$s_1$ $\in$ \nt{+expr}}
    \RightLabel{\scriptsize(\nt{expr-pxpr})}
    \BinaryInfC{$s$ $\in$ \nt{expr}}
  \DisplayProof
  \end{center}
  \begin{center}
    \AxiomC{$s$ $\in$ $\epsilon$}
    \RightLabel{\scriptsize($\epsilon$-\nt{+expr})}
    \UnaryInfC{$s$ $\in$ \nt{+expr}}
  \DisplayProof\qquad
    \AxiomC{$s_0$ $\in$ \terminal{+}}
    \AxiomC{$s_1$ $\in$ \nt{expr}}
    \RightLabel{\scriptsize(\nt{+expr})}
    \BinaryInfC{\strcat{$s_0$}{$s_1$} $\in$ \nt{+expr}}
  \DisplayProof
  \end{center}
  
  \todo{Pick one of these}
  
  Or, in the standard presentation:
  \begin{align*}
    \nt{expr} & \Coloneqq \nt{number}~|~\nt{pexpr}~\nt{+expr} \\
    \nt{+expr} & \Coloneqq \epsilon~|~\terminal{+}~\nt{expr} \\
    \nt{pexpr} & \Coloneqq \terminal{(}~\nt{expr}~\terminal{)} \\
    \nt{number} & \Coloneqq \nt{digit}~\nt{number?} \\
    \nt{number?} & \Coloneqq \epsilon~|~\nt{number} \\
    \nt{digit} & \Coloneqq \terminal{0}~|~\terminal{1}~|~\terminal{2}~|~\terminal{3}~|~\terminal{4}~|~\terminal{5}~|~\terminal{6}~|~\terminal{7}~|~\terminal{8}~|~\terminal{9}
  \end{align*}
  
  We have carefully constructed this grammar so that the first character of the string suffices to uniquely determine which rule of any given nonterminal to apply.
  
  S-expressions are a notation for nested space-separated lists.  By replacing \nt{digit} with a nonterminal that accepts any symbol in a given set, which must not contain either of the brackets, nor whitespace, and replacing \terminal{+} with a space character \terminal{\ }, we get a grammar for S-expressions:
  \begin{align*}
    \nt{expr} & \Coloneqq \nt{atom}~|~\nt{pexpr}~\nt{sexpr} \\
    \nt{sexpr} & \Coloneqq \epsilon~|~\nt{whitespace}~\nt{expr} \\
    \nt{pexpr} & \Coloneqq \terminal{(}~\nt{expr}~\terminal{)} \\
    \nt{atom} & \Coloneqq \nt{symbol}~\nt{atom?} \\
    \nt{atom?} & \Coloneqq \epsilon~|~\nt{atom} \\
    \nt{whitespace} & \Coloneqq \nt{whitespace-char}~\nt{whitespace?} \\
    \nt{whitespace?} & \Coloneqq \epsilon~|~\nt{whitespace} \\
    \nt{whitespace-char} & \Coloneqq \terminal{\ }~|~\terminal{\textbackslash n}~|~\terminal{\textbackslash t}~|~\terminal{\textbackslash r}
  \end{align*}
  
\section{The Splitting Strategy}
  \subsection{The Main Idea}
    The only rule not already handled is the rule that says that a \nt{pexpr}~\nt{+expr} is an \nt{expr}.  The key insight here is that, to know where to split, we need to know where the next \terminal{+} at the current level of parenthetization is.  If we can compute an appropriate lookup table in time linear in the length of the string, then our splitter overall with be linear.
    
  \subsection{Building the Lookup Table}
    We build the table by reading the string from right to left, storing for each character the location of the next \terminal{+} at the current level of parenthetization.  To compute this location we keep a list of the location of next \terminal{+} at every level of parenthetization.  For example, for the string ``((1+2)+3)+4'', we have the following lists at each point in the string:
    \todo{Insert computation here}
      \begin{itemize} \item  The generated table is  \\
          "5, 1, 0, -, -, 0 .
            , 4, 3, 2, 1
          "
    \end{itemize}
    
  \subsection{The Code}
    \todo{Insert Haskell-like code here}
 
    Optimization: Compute based on original string, lookup based on indices, don't need to compute substrings.
  \subsection{The Correctness Proof}
    To use this as a refinement rule, we need to prove it complete.  To do this, we prove \todo{explain correctness criterion and insert relation of paren-balanced-hiding on a string to properties of grammar.}

 

