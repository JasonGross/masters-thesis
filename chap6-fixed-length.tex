\chapter{fixed length nonterminals, parsing (ab)*; parsing \#s; parsing \#, ()}
  \begin{itemize} \item  Goals
    \begin{itemize} \item  Explore the framework 
    \item  Demonstrate that we can implement the "obvious" rules to handle a large swath of CFG rules \end{itemize}
  \item  At a Glance
    \begin{itemize} \item  There are some strategies that are obvious enough that it's easy for the computer to decide whether or not it's good to apply them.  For example, if a rule starts with a terminal, then we should split off one character, because terminals are always single characters.  These rules are enough to parse some simple grammars, such as the regular expression grammar (ab)*; the grammar accepting numbers; and the grammar accepting parenthesized numbers.  {}[GIVE GRAMMARS HERE]  In this section, we explain how we parse these grammars. \end{itemize}
  \item  The splitting strategy: if all strings parsed by a given item are the same length, then we can always split the string when faced with that nonterminal.
    \begin{itemize} \item  Walk through an example of parsing "abab" as "(ab)*", describing the splitting at each point. 
    \item  Another example: "((123))" 
    \item  For (ab)*, the item "a", and the item "b" only parse strings of length 1.  Thus when asked for the split for "a", then "b(ab)*", we can split after one character, and similarly after "b".  
    \item  For numbers with parentheses (of which numbers are a subgrammar), digits always have length 1, so we can split after the first character. \end{itemize}
  \item  Implementation as a refinement rule:
    \begin{itemize} \item  Describe the obligation Fiat presents us with for the splitter for (\#) {}[CODE HERE] 
    \item  Describe how each rule is handled 
    \item  For the relevant rules, we can compute the length at compile time.  Here is the algorithm. <Coq code here> 
    \item  To actually make use of this, we must satisfy the correctness criterion.  This is what refinement means.  We relate the length to the parse trees by a few correctness criteria. 
      \begin{itemize} \item  Note that we need to use only well-founded recursion. \end{itemize} 
    \item  We provide a decision procedure for the validity of this rule. \end{itemize}
  \item  In practice, we don't actually need to rewrite it; because it's never suboptimal to apply this rule (returning a single split location is just about the best we can do (TODO: handle invalid parses and backtracking better)), so we do it automatically, baking it into the initial goal, along with the indexed representation change (explain) \end{itemize}
%  
%\begin{verbatim}
%Lemma ComputationalSplitter'
%: FullySharpened (string_spec ab_star_grammar).
%Proof.
%  start honing parser using indexed representation.
%
%  hone method "splits".
%  {
%    simplify parser splitter.
%    finish honing parser method.
%  }
%
%  FullySharpenEachMethodWithoutDelegation.
%  extract delegate-free implementation.
%  simpl; higher_order_reflexivityT.
%Defined.
%\end{verbatim}
%
%\begin{verbatim}
%3 subgoals, subgoal 1 (ID 17)
%  
%  ============================
%   Sharpened
%     (ADTRep (string * (nat * nat))
%      { Def Constructor "new" (s: string) : rep :=
%          ret (s, (0, length s)) ,
%        Def Method "to_string" (s : rep, _ : ()) : string :=
%          ret (s, string_of_indexed s) ,
%        Def Method "is_char" (s : rep, ch : Ascii.ascii) : bool :=
%          ret (s, Equality.string_beq (string_of_indexed s) (String ch "")) ,
%        Def Method "get" (s : rep, n : nat) : (option Ascii.ascii) :=
%          ret (s, get n (string_of_indexed s)) ,
%        Def Method "length" (s : rep, _ : ()) : nat :=
%          ret (s, ilength s) ,
%        Def Method "take" (s : rep, n : nat) : () :=
%          ret (fst s, (fst (snd s), min (snd (snd s)) n), ()) ,
%        Def Method "drop" (s : rep, n : nat) : () :=
%          ret (fst s, (n + fst (snd s), NatFacts.minusr (snd (snd s)) n), ()) ,
%        Def Method "splits" (s : rep, p : (item Ascii.ascii *
%                                           production Ascii.ascii)) : 
%        (list nat) :=
%          dummy <- {_ : list nat | True};
%          ls <- If [Terminal "a"%char; Terminal "b"%char;
%                   NonTerminal "(ab)*"] =p fst p :: snd p Then 
%                ret [1]
%                Else (If [Terminal "b"%char; NonTerminal "(ab)*"] =p
%                         fst p :: snd p Then ret [1]
%                      Else (If [NonTerminal "(ab)*"] =p fst p :: snd p
%                            Then ret [ilength s] Else 
%                            ret dummy));
%          ret (s, ls) ,
%        Def Method "rules" (s : rep, p : (productions Ascii.ascii)) : 
%        (list nat) :=
%          dummy <- {_ : list nat | True};
%          ls <- If ContextFreeGrammarEquality.productions_beq
%                     Equality.ascii_beq
%                     [[];
%                     [Terminal "a"%char; Terminal "b"%char;
%                     NonTerminal "(ab)*"]] p
%                Then option_rect
%                       (fun _ : option Ascii.ascii => Comp (list nat))
%                       (fun ch : Ascii.ascii =>
%                        If Equality.ascii_beq "a"%char ch Then 
%                        ret [1] Else ret dummy) (ret [0])
%                       (get 0 (string_of_indexed s)) Else 
%                ret dummy;
%          ret (s, ls)  })%ADT
%
%subgoal 2 (ID 9) is:
% forall idx : StringBound.BoundedString,
% refineADT (Sharpened_DelegateSpecs ?4 idx)
%   (ComputationalADT.LiftcADT
%      (existT (ComputationalADT.pcADT (Sharpened_DelegateSigs ?4 idx))
%         (?6 idx) (?7 idx)))
%subgoal 3 (ID 10) is:
% refineADT (ComputationalADT.LiftcADT (Sharpened_Implementation ?4 ?6 ?7))
%   (ComputationalADT.LiftcADT ?5)
%
%(dependent evars: ?3 using , ?4 open, ?5 open, ?6 open, ?7 open, ?11 using ,)
%\end{verbatim}
%
%
%\begin{verbatim}
%(* hone method "splits". *)
%4 subgoals, subgoal 1 (ID 60)
%  
%  r_n : string * (nat * nat)
%  n : item Ascii.ascii * production Ascii.ascii
%  H := ?50 : hiddenT
%  ============================
%   refine
%     (dummy <- {_ : list nat | True};
%      ls <- If [Terminal "a"%char; Terminal "b"%char; NonTerminal "(ab)*"] =p
%               fst n :: snd n Then ret [1]
%            Else (If [Terminal "b"%char; NonTerminal "(ab)*"] =p
%                     fst n :: snd n Then ret [1]
%                  Else (If [NonTerminal "(ab)*"] =p fst n :: snd n
%                        Then ret [ilength r_n] Else 
%                        ret dummy));
%      ret (r_n, ls)) (H r_n n)
%
%(* simplify parser splitter. *)
%
%1 focused subgoals (unfocused: 3)
%, subgoal 1 (ID 362)
%  
%  r_n : string * (nat * nat)
%  n : item Ascii.ascii * production Ascii.ascii
%  H := ?50 : hiddenT
%  ============================
%   refine
%     (ret
%        (r_n,
%        [If ([Terminal "a"%char; Terminal "b"%char; NonTerminal "(ab)*"] =p
%             fst n :: snd n)
%            || ([Terminal "b"%char; NonTerminal "(ab)*"] =p fst n :: snd n)
%         Then 1
%         Else (If [NonTerminal "(ab)*"] =p fst n :: snd n Then 
%               ilength r_n Else 0)])) (H r_n n)
%\end{verbatim}
%
%
%\begin{verbatim}
%  Definition indexed_spec : ADT (string_rep Ascii.ascii) := ADTRep T {
%    Def Constructor "new"(s : String.string) : rep :=
%      ret (s, (0, String.length s)),
%
%    Def Method "to_string"(s : rep, x : unit) : String.string :=
%      ret (s, string_of_indexed s),
%
%    Def Method "is_char"(s : rep, ch : Ascii.ascii) : bool  :=
%      ret (s, string_beq (string_of_indexed s) (String.String ch "")),
%
%    Def Method "get"(s : rep, n : nat) : option Ascii.ascii  :=
%      ret (s, iget n s),
%
%    Def Method "length"(s : rep, x : unit) : nat :=
%      ret (s, ilength s),
%
%    Def Method "take"(s : rep, n : nat) : unit :=
%      ret ((fst s, (fst (snd s), min (snd (snd s)) n)), tt),
%
%    Def Method "drop"(s : rep, n : nat) : unit :=
%      ret ((fst s, (fst (snd s) + n, snd (snd s) - n)), tt),
%
%    Def Method "splits"(s : rep, p : item Ascii.ascii * production Ascii.ascii) : list nat :=
%      fallback_ls <- { ls : list nat
%                     | match fst p with
%                         | Terminal _
%                           => True
%                         | NonTerminal _
%                           => if has_only_terminals (snd p)
%                              then True
%                              else split_list_is_complete G (string_of_indexed s) (fst p) (snd p) ls
%                       end };
%      let ls := (match snd p, fst p with
%                   | nil, _
%                     => [ilength s]
%                   | _::_, Terminal _
%                     => [1]
%                   | _::_, NonTerminal _
%                     => if has_only_terminals (snd p)
%                        then [ilength s - List.length (snd p)]
%                        else fallback_ls
%                 end) in
%      ret (s, ls)
%  }.
%
%
%
%  Definition split_list_is_complete `{HSL : StringLike Char} (str : String) (it : item Char) (its : production Char)
%             (splits : list nat)
%  : Prop
%    := forall n,
%         n <= length str
%         -> production_is_reachable (it::its)
%         -> forall (pit : parse_of_item G (take n str) it)
%                   (pits : parse_of_production G (drop n str) its),
%              Forall_parse_of_item (fun _ nt => List.In nt (Valid_nonterminals G)) pit
%              -> Forall_parse_of_production (fun _ nt => List.In nt (Valid_nonterminals G)) pits
%              -> List.In n splits.
%
%\end{verbatim}
%
%
%
%\begin{verbatim}
%Inductive length_result := same_length (n : nat) | different_lengths | cyclic_length | not_yet_handled_empty_rule.
%
%Coercion collapse_length_result (l : length_result) : option nat
%  := match l with
%       | same_length n => Some n
%       | _ => None
%     end.
%
%Fixpoint length_of_any_production' {Char} (length_of_any_nt : String.string -> length_result)
%         (its : production Char) : length_result
%  := match its with
%       | nil => same_length 0
%       | (Terminal _)::xs => match length_of_any_production' length_of_any_nt xs with
%                               | same_length n => same_length (S n)
%                               | different_lengths => different_lengths
%                               | cyclic_length => cyclic_length
%                               | not_yet_handled_empty_rule => not_yet_handled_empty_rule
%                             end
%       | (NonTerminal nt)::xs => match length_of_any_nt nt, length_of_any_production' length_of_any_nt xs with
%                                   | same_length n1, same_length n2 => same_length (n1 + n2)
%                                   | cyclic_length, _ => cyclic_length
%                                   | _, cyclic_length => cyclic_length
%                                   | different_lengths, _ => different_lengths
%                                   | _, different_lengths => different_lengths
%                                   | not_yet_handled_empty_rule, _ => not_yet_handled_empty_rule
%                                   | _, not_yet_handled_empty_rule => not_yet_handled_empty_rule
%                                 end
%     end.
%
%Lemma length_of_any_production'_ext {Char}
%      f g
%      (ext : forall b, f b = g b)
%      b
%: @length_of_any_production' Char f b = length_of_any_production' g b.
%Proof.
%  induction b as [ | x ]; try reflexivity; simpl.
%  destruct x; rewrite ?IHb, ?ext; reflexivity.
%Qed.
%
%Definition length_of_any_productions'_f
%  := (fun x1 x2
%      => match x1, x2 with
%           | same_length n1, same_length n2 => if Nat.eq_dec n1 n2 then same_length n1 else different_lengths
%           | cyclic_length, _ => cyclic_length
%           | _, cyclic_length => cyclic_length
%           | _, different_lengths => different_lengths
%           | different_lengths, _ => different_lengths
%           | not_yet_handled_empty_rule, _ => not_yet_handled_empty_rule
%           | _, not_yet_handled_empty_rule => not_yet_handled_empty_rule
%         end).
%
%Arguments length_of_any_productions'_f !_ !_ / .
%
%Lemma length_of_any_productions'_f_same_length {n x1 x2}
%: length_of_any_productions'_f x1 x2 = same_length n
%  <-> (x1 = same_length n /\ x2 = same_length n).
%Proof.
%  destruct x1, x2; simpl in *;
%  repeat match goal with
%           | _ => reflexivity
%           | [ H : context[Nat.eq_dec ?x ?y] |- _ ] => destruct (Nat.eq_dec x y)
%           | [ |- context[Nat.eq_dec ?x ?y] ] => destruct (Nat.eq_dec x y)
%           | _ => progress subst
%           | [ H : same_length _ = same_length _ |- _ ] => inversion H; clear H
%           | _ => intro
%           | [ H : _ /\ _ |- _ ] => destruct H
%           | [ |- _ /\ _ ] => split
%           | [ |- _ <-> _ ] => split
%           | _ => congruence
%           | _ => tauto
%         end.
%Qed.
%
%Lemma length_of_any_productions'_f_same_length_fold_right {n x1 x2}
%: fold_right length_of_any_productions'_f x1 x2 = same_length n
%  <-> (x1 = same_length n /\ fold_right and True (map (fun k => k = same_length n) x2)).
%Proof.
%  induction x2; simpl in *; eauto; try tauto.
%  rewrite length_of_any_productions'_f_same_length.
%  rewrite IHx2.
%  tauto.
%Qed.
%
%Definition length_of_any_productions' {Char} (length_of_any_nt : String.string -> length_result)
%           (prods : productions Char)
%: length_result
%  := match prods with
%       | nil => not_yet_handled_empty_rule
%       | p::ps => fold_right
%                    length_of_any_productions'_f
%                    (length_of_any_production' length_of_any_nt p)
%                    (map (length_of_any_production' length_of_any_nt) ps)
%     end.
%
%Lemma length_of_any_productions'_ext {Char}
%      f g
%      (ext : forall b, f b = g b)
%      b
%: @length_of_any_productions' Char f b = length_of_any_productions' g b.
%Proof.
%  unfold length_of_any_productions'.
%  destruct b as [ | ? b]; trivial; [].
%  induction b; try reflexivity; simpl;
%  erewrite length_of_any_production'_ext by eassumption; trivial; [].
%  edestruct (length_of_any_production' g);
%    rewrite IHb; reflexivity.
%Qed.
%
%Definition length_of_any_nt_step {Char} (G : grammar Char) (predata := @rdp_list_predata _ G)
%           (valid0 : nonterminals_listT)
%           (length_of_any_nt : forall valid, nonterminals_listT_R valid valid0
%                                             -> String.string -> length_result)
%           (nt : String.string)
%: length_result.
%Proof.
%  refine (if Sumbool.sumbool_of_bool (is_valid_nonterminal valid0 nt)
%          then length_of_any_productions'
%                 (@length_of_any_nt (remove_nonterminal valid0 nt) (remove_nonterminal_dec _ _ _))
%                 (Lookup G nt)
%          else different_lengths);
%  assumption.
%Defined.
%
%Lemma length_of_any_nt_step_ext {Char G}
%      x0 f g
%      (ext : forall y p b, f y p b = g y p b)
%      b
%: @length_of_any_nt_step Char G x0 f b = length_of_any_nt_step g b.
%Proof.
%  unfold length_of_any_nt_step.
%  edestruct Sumbool.sumbool_of_bool; trivial.
%  apply length_of_any_productions'_ext; eauto.
%Qed.
%
%Definition length_of_any_nt {Char} (G : grammar Char) initial : String.string -> length_result
%  := let predata := @rdp_list_predata _ G in
%     @Fix _ _ ntl_wf _
%          (@length_of_any_nt_step _ G)
%          initial.
%
%Definition length_of_any {Char} (G : grammar Char) : String.string -> length_result
%  := @length_of_any_nt Char G initial_nonterminals_data.
%
%Definition length_of_any_productions {Char} G := @length_of_any_productions' Char (@length_of_any Char G).
%
%
%\end{verbatim}
%
%\begin{verbatim}
%Global Arguments ComputationalSplitter / .
%
%Require Import Fiat.Parsers.ParserFromParserADT.
%Require Import Fiat.Parsers.ExtrOcamlParsers.
%Import Fiat.Parsers.ExtrOcamlParsers.HideProofs.
%
%Time Definition ab_star_parser (str : String.string) : bool
%  := Eval simpl in has_parse (parser ComputationalSplitter) str.
%
%Print ab_star_parser.
%
%Recursive Extraction ab_star_parser.
%
%Definition test0 := ab_star_parser "".
%Definition test1 := ab_star_parser "ab".
%Definition str400 := "abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababab".
%Definition test2 := ab_star_parser (str400 ++ str400 ++ str400 ++ str400).
%
%Recursive Extraction test0 test1 test2.
%
%\end{verbatim}