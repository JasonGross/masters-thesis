\section{explanation of fiat framework for refining splitters}
  \begin{itemize} \item  Goals
    \begin{itemize} \item  Already described parsing, already have goals (build efficient parser) (refresh memory on this, and justify), now describe the tools 
    \item  Describe why these are the pieces we need 
    \item  Describe Fiat 
    \item  Describe Splitter Refinement 
    \item  Describe Basic Optimizations \end{itemize}
  \item{} {}[Rehash parsing, rehash goals, intro rest of paper]
    \begin{itemize} \item  At a Glance 
      \begin{itemize} \item  We have now finished describing the general parsing algorithm, as well as its correctness proofs; we have an algorithm, parametrized on an "oracle" that describes how to split the string for each rule, that decides whether or not a given structure can be imposed on any block of unstructured text.  For the remainder of this paper, we will focus on how to implement the splitting oracle.  Correctness is not enough, in general; algorithms also need to be fast to use.  We thus focus primarily on efficiency when designing splitting algorithms. 
      \item  The goals of this work, as mentioned in section {}[INTRO], are to present a framework for constructing proven-correct parsers incrementally, and argue for its eventual feasability.  To this end, we build on the previous work of Fiat {}[CITE], to allow us to build programs incrementally while maintaining correctness guarantees.  This section will describe Fiat, and how it is used in this project.  The following sections will focus more on the details of the splitting algorithms, and less on the details of Fiat. \end{itemize} \end{itemize}
  \item  {}[Justification of tools] What counts as efficient?
    \begin{itemize} \item  To guide our implementations, we characterize efficient splitters informally, as follows.  Although our eventual concrete efficiency target is to be competitive with extant open source JavaScript parsers, when designing algorithms, we aim at the asymptotic efficiency target of linearity in the length of the string.  In practice, the dominating concern is that doubling the length of the string should only double the duration of the parse, and not quadruple it (or more!).  {}[CITATION NEEDED]  To be efficient, it suffices to have the splitter return at most one index.  In this case, the parsing time is O(length of string * (product over all nonterminals of the number of possible rules for that nonterminal)). Here is an example of hitting the worst-case scenario: {}[EXAMPLE HERE] 
      \begin{itemize} \item  <justification> \end{itemize} 
    \item  To avoid hitting this worst-case scenario, we can use a nonterminal-picker, which returns the list of possible production rules for a given string and nonterminal.  As long as it returns at most one possible rule in most cases, in constant time, the parsing time will be O(length of string); backtracking will never happen.  This is future work. \end{itemize}
  \item  {}[Describe Fiat]
    \begin{itemize} \item  Efficiency targets in hand, we move on to incremental construction.  The key idea is that parsing rules tend to fall into clumps that are similar between grammars.  For example, many grammars use delimiters (such as whitespace, commas, or binary operation symbols) as splitting points, but only between well-balanced brackets (such as double quotes, parentheses, or comment markers).  We can take advantage of these similarities by baking the relevant algorithms into basic building blocks, which can then be reused across different grammars.  To allow this reuse, we construct the splitters incrementally, allowing us to deal with different rules in different ways. 
    \item  The Fiat framework {}[citation] is the scaffolding of our splitter implementations.  As a framework, the goal of Fiat is to enable library-writers to construct algorithmic building blocks packaged with correctness guarantees, in such a way that users can easily and mostly-automatically make use of these building blocks when they apply. 
    \item  The Fiat Mindset 
      \begin{itemize} \item  The correctness guarantees of Fiat are based on specifications in the form of Gallina propositions.  For example, the specification of a valid \verb|has_parse| method is that \verb|has_parse str = true <-> there exists a parse tree of str|.  Fiat allows incremental construction of algorithms by providing a language for seamlessly mixing specifications and code.  The language is a light-weight monadic syntax with one extra operator: a non-deterministic choice operator.  {}[DIAGRAM OF SYNTAX]  An algorithm starts out as a nondeterministic choice of a value satisfying the specification.  Coding then proceeds by refinement.  {}[DIAGRAM DEFINITION OF REFINEMENT] 
      \item  In our use case, we express the specification of the splitter as a nondeterministic choice of a list of split locations, such that any splitting location that results in a valid parse tree is contained in the list.  We then refine this into a choice of a splitting location for each rule actually in the grammar (checking for equality with the given rule), and then can refine (implement) the splitter for each rule separately.   For example, if we are looking to split the string at the location of the first '+' character, we might first pick the list of "valid locations to split at", and then refine that into a computation that picks the location of the first '+', and returns the singleton list containing that, and then replace the remaining bit of nondeterminism with a computation of the location of the first '+'. 
      \item  The key to making Fiat work is that the refinement rules package their correctness properties, so users don't have to worry about correctness when programming by refinement.  We use Coq's setoid rewriting machinery to automatically glue together the various correctness proofs when refining only a part of a program. \end{itemize} 
    \item  We now describe the refinements that we do within this framework, to implement efficient splitters. \end{itemize}
  \item  {}[Basic opt] First optimization: indexed representation of strings
    \begin{itemize} \item  One optimization that is always possible is to represent the current string being parsed in this recursive call as a pair of indices into the original string.  This allows us to optimize the code doing string manipulation, as it will no longer need to copy strings around, only do index arithmetic. \end{itemize}
  \item  {}[Basic opt] Intro to next sections
    \begin{itemize} \item  In the next few sections, we build up various strategies for splitters.  Although our eventual target is JavaScript, we cover only a more modest target of very simple arithmetical expressions in this paper.  We begin by tying up the (ab)* grammar, and then moving on to parse numbers, parenthesized numbers, expressions with only numbers and "+", and then expressions with numbers, "+" and parentheses. 
    \item  For each grammar, the Fiat framework presents us with goals describing the unimplemented portion of the splitter for this particular grammar.  For example, the goal for the (ab)* grammar looks like this: <INSERT GOAL>.  To get to this goal, we write this code: <COQ CODE HERE, with comments describing what each line does>  We thus have to describe how to split a string for the rules <RULES HERE>, and provide proofs that these splitting strategies are complete.  We begin the next section with this splitting strategy. \end{itemize} \end{itemize}