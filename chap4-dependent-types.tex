\chapter{Completeness, Soundness, and Parsing Parse Trees} \label{ch:dep-types}
\section{Proving Completeness: Conceptual Approach} \label{sec:conceptual-completeness} \label{sec:min:conceptual-intro}
  Recall from \autoref{sec:solve-nontermination} that the essential difficulty with proving completeness is dealing with the cases where our parser aborts early; we must show that doing so does not eliminate good parse trees.

  The key is to define an intermediate type, that of ``minimal parse trees.''  A ``minimal'' parse tree is simply a parse tree in which the same (string, nonterminal) pair does not appear more than once in any path of the tree.  Defining this type allows us to split the completeness problem in two; we can show separately that every parse tree gives rise to a minimal parse tree, and that having a minimal parse tree in hand implies that our parser succeeds (returns \true\space or \Some{\termhole}).

  Our dependently typed parsing algorithm subsumes the soundness theorem, the minimization of parse trees, and the proof that having a minimal parse tree implies that our parser succeeds.  We write one parametrically polymorphic parsing function that supports all three modes, plus the several different sorts of parsers (recognizers, generating parse trees, running semantic actions).  That level of genericity requires us to be flexible in which type represents ``strings,'' or inputs to parsers.  We introduce a parameter that is often just the normal \String{} type, but which needs to be instantiated as the type of \emph{parse trees themselves} to get a proof of parse tree minimizability.  That is, we ``parse'' parse trees to minimize them, reusing the same logic that works for the normal parsing problem.

  Before presenting our algorithm's interface, we will formally define and explain minimal parse trees, which will provide motivation for the type signatures of our parser's arguments.

\section{Minimal Parse Trees: Formal Definition} \label{sec:min:formal-definition}
  In order to make tractable the second half of the completeness theorem, that having a minimal parse tree implies that parsing succeeds, it is essential to make the inductive structure of minimal parse trees mimic precisely the structure of the parsing algorithm.  A minimal parse tree thus might better be thought of as a parallel trace of parser execution.

  As in \autoref{sec:formal-parse-tree-definition}, we define mutually inductive type families of \indname{MinParseTreeOf}s and \indname{MinItemsTreeOf}s for a given grammar.  Because our parser proceeds by well-founded recursion on the length of the string and the list of nonterminals not yet attempted for that string, we must include both of these in the types.  Let us call the initial list of all nonterminals \farg{unseen$_0$}.
  \begin{align*}
    \indname{MinParseTreeOf} & \oftypesep \String \typeto \typelist{\Nonterminal} \\
    & \typeto \indname{Item} \typeto \String \typeto \Type \\
    \indname{MinItemsTreeOf} & \oftypesep \String \typeto \typelist{\Nonterminal} \\
    & \typeto \typelist{\indname{Item}} \typeto \String \typeto \Type
  \end{align*}
  Much as in the case of parse trees, for any terminal character \farg{ch}, any string \farg{s$_0$}, and any list of nonterminals \farg{unseen}, we have the constructor
  \begin{align*}
    \fname{min\_parse$_{\terminal{\farg{ch}}}$} & \oftypesep \indname{MinParseTreeOf}~~\farg{s$_0$}~~\farg{unseen}~~\terminal{\farg{ch}}~~\str{\farg{ch}}
  \end{align*}

  For any production \farg{rule} mapping a nonterminal \farg{nt} to a sequence of items \farg{its}, any string \farg{s$_0$}, any list of nonterminals \farg{unseen}, and any string \farg{s}, we have two constructors, corresponding to the two ways of progressing with respect to the well-founded relation.  Letting $\farg{unseen$'$}\defeq\farg{unseen} - \{\farg{nt}\}$, we have the following, where we interpret the $<$ relation on strings in terms of lengths.
  \begin{align*}
    (\farg{rule})_< & \oftypesep \farg{s} < \farg{s$_0$} \\
    & \typeto \indname{MinItemsTreeOf}~~\farg{s}~~\farg{unseen$_0$}~~\farg{its}~~\farg{s} \\
    & \typeto \indname{MinParseTreeOf}~~\farg{s$_0$}~~\farg{unseen}~~\farg{nt}~~\farg{s} \\
    (\farg{rule})_= & \oftypesep \farg{s} = \farg{s$_0$} \\
    & \typeto \farg{nt} \in \farg{unseen} \\
    & \typeto \indname{MinItemsTreeOf}~~\farg{s$_0$}~~\farg{unseen$'$}~~\farg{its}~~\farg{s} \\
    & \typeto \indname{MinParseTreeOf}~~\farg{s$_0$}~~\farg{unseen}~~\farg{nt}~~\farg{s}
  \end{align*}
  In the first case, the length of the string has decreased, so we may reset the list of not-yet-seen nonterminals, as long as we reset the base of well-founded recursion \farg{s$_0$} at the same time.  In the second case, the length of the string has not decreased, so we require that we have not yet seen this nonterminal, and we then remove it from the list of not-yet-seen nonterminals.

  Finally, for any string \farg{s$_0$} and any list of nonterminals \farg{unseen}, we have the following two constructors of \indname{MinItemsTreeOf}.
  \begin{align*}
    \fname{min\_parse$_\nil$} & \oftypesep \indname{MinItemsTreeOf}~~\farg{s$_0$}~~\farg{unseen}~~\nil~~\str{} \\
    \fname{min\_parse$_{\cons{}{}}$} & \oftypesep \strcat{\farg{s$_1$}}{\farg{s$_2$}} \le \farg{s$_0$} \\
    & \typeto \indname{MinParseTreeOf}~~\farg{s$_0$}~~\farg{unseen}~~\farg{it}~~\farg{s$_1$} \\
    & \typeto \indname{MinItemsTreeOf}~~\farg{s$_0$}~~\farg{unseen}~~\farg{its}~~\farg{s$_2$} \\
    & \typeto
    \indname{MinItemsTreeOf}~~\farg{s$_0$}~~\farg{unseen}~~(\cons{\farg{it}}{\farg{its}})~~\strcat{\farg{s$_1$}}{\farg{s$_2$}}
  \end{align*}
  The requirement that $\strcat{\farg{s$_1$}}{\farg{s$_2$}} \le \farg{s$_0$}$ in the second case ensures that we are only making well-founded recursive calls.

  Once again, for brevity, we will sometimes use the notation \minparsetreetype{\farg{s$_0$}}{\farg{v}}{\farg{X}}{\farg{s}} to denote both \indname{MinParseTreeOf}~\farg{s$_0$}~\farg{v}~\farg{X}~\farg{s} and \indname{MinItemsTreeOf}~\farg{s$_0$}~\farg{v}~\farg{X}~\farg{s}, relying on context to disambiguate based on the type of \farg{X}.  Additionally, we will sometimes fold the constructors of \indname{MinItemsTreeOf} into the two (\farg{rule}) constructors of \indname{MinParseTreeOf}, to mimic the natural-deduction trees.

\section{Parser Interface} \label{sec:parser-interface}
  Roughly speaking, we read the interface of our general parser off from the types of the constructors for minimal parse trees.  Every constructor leads to one parameter passed to the parser, much as one derives the types of general ``fold'' functions for arbitrary inductive datatypes.  For instance, lists have constructors \constructorname{nil} and \constructorname{cons}, so a fold function for lists has arguments corresponding to \constructorname{nil} (initial accumulator) and \constructorname{cons} (step function).  The situation for the type of our parser is similar, though we need parallel success (managed to parse the string) and failure (could prove that no parse is possible) parameters for each constructor of minimal parse trees.

  The type signatures in the interface are presented in \autoref{fig:parser-interface}.  We explain each type one by one, presenting various instantiations as examples.  Note that the interface we actually implemented is also parameterized over a type of \String s, which we will instantiate with parse trees later in this paper.  The interface we present here fixes \String, for conciseness.
  
  \todo{Fix the figure so it fits on one page}

\begin{figure*} \caption{The dependently typed interface of our parser}\label{fig:parser-interface}
We use \ParseQuery\space to denote the type of all propositions like ``\texttt{\str{a} $\in$ \terminal{a}}''; a query consists of a string and a grammar rule the string might be parsed into.  We use the same notation for \ParseQuery{} and \indname{ParseTree} inhabitants.  All \fname{*\_success} and \fname{*\_failure} type signatures are implicitly parameterized over a string \farg{s$_0$} and a list of nonterminals \farg{unseen}.  We assume we are given \oftype{\fname{unseen$_0$}}{\typelist{\Nonterminal}}.
\begin{align*}
  \fname{T$_{\fname{success}}$},~~\fname{T$_{\fname{failure}}$} & \oftypesep \String \typeto \typelist{\Nonterminal} \typeto \ParseQuery \typeto \Type \\
  %\\
  \fname{split} & \oftypesep \String \typeto \typelist{\Nonterminal} \typeto \ParseQuery \typeto \typelist{\nat} \\ \\
  \fname{terminal\_success} & \oftypesep (\oftype{\farg{ch}}{\Terminal})
   \typeto \fname{T$_{\fname{success}}$}~~\farg{s$_0$}~~\farg{unseen}~~ \left(\parsetreetype{\terminal{\farg{ch}}}{\str{\farg{ch}}}\right) \\
  \fname{terminal\_failure} & \oftypesep (\oftype{\farg{ch}}{\Terminal})
   \typeto (\oftype{\farg{s}}{\String})
   \typeto \farg{s} \ne \str{\farg{ch}}
   \typeto \fname{T$_{\fname{failure}}$}~~\farg{s$_0$}~~\farg{unseen}~~ \left(\parsetreetype{\terminal{\farg{ch}}}{\farg{s}}\right) \\
  %\\
  \fname{nil\_success} & \oftypesep \fname{T$_{\fname{success}}$}~~\farg{s$_0$}~~\farg{unseen}~~\left(\parsetreetype{\epsilon}{\str{}}\right) \\
  \fname{nil\_failure} & \oftypesep (\oftype{\farg{s}}{\String})
   \typeto \farg{s} \neq \str{}
   \typeto \fname{T$_{\fname{failure}}$}~~\farg{s$_0$}~~\farg{unseen}~~\left(\parsetreetype{\epsilon}{\farg{s}}\right) \\
   \\
  \fname{cons\_success} & \oftypesep (\oftype{\farg{it}}{\indname{Item}})
   \typeto (\oftype{\farg{its}}{\typelist{\indname{Item}}})
   \typeto (\oftype{\farg{s$_1$}}{\String})
   \typeto (\oftype{\farg{s$_2$}}{\String}) \\
   & \typeto \strcat{\farg{s$_1$}}{\farg{s$_2$}} \le \farg{s$_0$} \\
   & \typeto \fname{T$_{\fname{success}}$}~~\farg{s$_0$}~~\farg{unseen}~~\left(\parsetreetype{\farg{it}}{\farg{s$_1$}}\right) \\
   & \typeto \fname{T$_{\fname{success}}$}~~\farg{s$_0$}~~\farg{unseen}~~\left(\parsetreetype{\farg{its}}{\farg{s$_2$}}\right) \\
   & \typeto \fname{T$_{\fname{success}}$}~~\farg{s$_0$}~~\farg{unseen}~~\left(\parsetreetype{\cons{\farg{it}}{\farg{its}}}{\strcat{\farg{s$_1$}}{\farg{s$_2$}}}\right) \\
  \fname{cons\_failure} & \oftypesep (\oftype{\farg{it}}{\indname{Item}})
   \typeto (\oftype{\farg{its}}{\typelist{\indname{Item}}})
   \typeto (\oftype{\farg{s}}{\String}) \\
   & \typeto \farg{s} \le \farg{s$_0$} \\
   & \typeto \big(\forall~(\farg{s$_1$}, \farg{s$_2$}) \in \fname{split}~~\farg{s$_0$}~~\farg{unseen}~~\left(\parsetreetype{\cons{\farg{it}}{\farg{its}}}{\farg{s}}\right), \\
   & \phantom{{}\typeto\left(\forall\vphantom{\parsetreetype{}{}}{}\right.}~~
     \typesum{\fname{T$_{\fname{failure}}$}~~\farg{s$_0$}~~\farg{unseen}~~\left(\parsetreetype{\farg{it}}{\farg{s$_1$}}\right)}
     {\fname{T$_{\fname{failure}}$}~~\farg{s$_0$}~~\farg{unseen}~~\left(\parsetreetype{\farg{its}}{\farg{s$_2$}}\right)}\big) \\
   & \typeto \fname{T$_{\fname{failure}}$}~~\farg{s$_0$}~~\farg{unseen}~~\left(\parsetreetype{\cons{\farg{it}}{\farg{its}}}{\farg{s}}\right) \\
   \\
  \fname{production\_success$_<$} & \oftypesep
   (\oftype{\farg{its}}{\typelist{\indname{Item}}})
   \typeto (\oftype{\farg{nt}}{\Nonterminal})
   \typeto (\oftype{\farg{s}}{\String}) \\
   & \typeto \farg{s} < \farg{s$_0$} \\
   & \typeto \left(\oftype{\farg{p}}{\text{a production mapping \farg{nt} to \farg{its}}}\right) \\
   & \typeto \fname{T$_{\fname{success}}$}~~\farg{s}~~\fname{unseen$_0$}~~\left(\parsetreetype{\farg{its}}{\farg{s}}\right) \\
   & \typeto \fname{T$_{\fname{success}}$}~~\farg{s$_0$}~~\farg{unseen}~~\left(\parsetreetype{\farg{nt}}{\farg{s}}\right) \\
  \fname{production\_success$_=$} & \oftypesep
   (\oftype{\farg{its}}{\typelist{\indname{Item}}})
   \typeto (\oftype{\farg{nt}}{\Nonterminal})
   \typeto (\oftype{\farg{s}}{\String})
   \\
   %& \typeto \farg{s} = \farg{s$_0$} \\
   & \typeto \farg{nt} \in \farg{unseen} \\
   & \typeto \left(\oftype{\farg{p}}{\text{a production mapping \farg{nt} to \farg{its}}}\right) \\
   & \typeto \fname{T$_{\fname{success}}$}~~\farg{s$_0$}~~\left(\farg{unseen} - \{\farg{nt}\}\right)~~\left(\parsetreetype{\farg{its}}{\farg{s}}\right) \\
   & \typeto \fname{T$_{\fname{success}}$}~~\farg{s$_0$}~~\farg{unseen}~~\left(\parsetreetype{\farg{nt}}{\farg{s}}\right) \\
  \fname{production\_failure$_<$} & \oftypesep
   (\oftype{\farg{nt}}{\Nonterminal})
   \typeto (\oftype{\farg{s}}{\String})
   \\
   & \typeto \farg{s} < \farg{s$_0$} \\
   & \typeto \big(\forall~(\oftype{\farg{its}}{\typelist{\indname{Item}}})~(\oftype{\farg{p}}{\text{a production mapping \farg{nt} to \farg{its}}}),~
     \fname{T$_{\fname{failure}}$}~~\farg{s}~~\fname{unseen$_0$}~~\left(\parsetreetype{\farg{its}}{\farg{s}}\right)\big) \\
   & \typeto \fname{T$_{\fname{failure}}$}~~\farg{s$_0$}~~\farg{unseen}~~\left(\parsetreetype{\farg{nt}}{\farg{s}}\right) \\
  \fname{production\_failure$_=$} & \oftypesep
   (\oftype{\farg{nt}}{\Nonterminal})
   \typeto (\oftype{\farg{s}}{\String}) \\
   & \typeto \farg{s} = \farg{s$_0$} \\
   & \typeto \big(\forall~(\oftype{\farg{its}}{\typelist{\indname{Item}}})~(\oftype{\farg{p}}{\text{a production mapping \farg{nt} to \farg{its}}}),~
        \fname{T$_{\fname{failure}}$}~~\farg{s$_0$}~~\left(\farg{unseen} - \{\farg{nt}\}\right)~~\left(\parsetreetype{\farg{its}}{\farg{s}}\right)\big) \\
   & \typeto \fname{T$_{\fname{failure}}$}~~\farg{s$_0$}~~\farg{unseen}~~\left(\parsetreetype{\farg{nt}}{\farg{s}}\right) \\
  \fname{production\_failure$_{\not\in}$} & \oftypesep
   (\oftype{\farg{nt}}{\Nonterminal})
   \typeto (\oftype{\farg{s}}{\String}) \\
   & \typeto \farg{s} = \farg{s$_0$} \\
   & \typeto \farg{nt}\not\in \farg{unseen} \\
   & \typeto \fname{T$_{\fname{failure}}$}~~\farg{s$_0$}~~\farg{unseen}~~\left(\parsetreetype{\farg{nt}}{\farg{s}}\right)
\end{align*}
\end{figure*}

  Since we want to be able to specialize our parser to return either \Bool\space or \typeoption{\!\!\indname{ParseTree}}, we want to be able to reuse our soundness and completeness proofs for both.  Our strategy for generalization is to parameterize on dependent type families for ``success'' and ``failure'', so we can use relational parametricity to ensure that all instantiations of the parser succeed or fail together.  The parser has the rough type signature
  $$\oftype{\fname{parse}}{\Nonterminal~\typeto~\String~\typeto~\typesum{\fname{T$_{\fname{success}}$}}{\fname{T$_{\fname{failure}}$}}}.$$

  To instantiate the parser as a Boolean recognizer, we instantiate everything trivially; we use the fact that $\typesum{\Unit}{\Unit}\cong\Bool$, where \Unit\space is the singleton type inhabited by \unittt.  Just to show how trivial everything is, here is a precise instantiation of the parser, still parameterized over the initial list of nonterminals and the splitter, where $\Unit$ is the one constructor of the one-element type~$\Unit$:
  {\allowdisplaybreaks
  \begin{align*}
    & \fname{T$_{\fname{success}}$}~\termhole~\termhole~\termhole \defeq \Unit \\
    & \fname{T$_{\fname{failure}}$}~\termhole~\termhole~\termhole \defeq \Unit \\
    \\
    & \fname{terminal\_success}~\termhole~\termhole~\termhole \defeq \unittt \\
    & \fname{terminal\_failure}~\termhole~\termhole~\termhole~\termhole~\termhole \defeq \unittt \\
    & \fname{nil\_success}~\termhole~\termhole \defeq \unittt \\
    & \fname{nil\_failure}~\termhole~\termhole~\termhole~\termhole \defeq \unittt \\
    & \fname{cons\_success}~\termhole~\termhole~\termhole~\termhole~\termhole~\termhole~\termhole~\termhole~\termhole \defeq \unittt \\
    & \fname{cons\_failure}~\termhole~\termhole~\termhole~\termhole~\termhole~\termhole~\termhole \defeq \unittt \\
    & \fname{production\_success$_<$}~\termhole~\termhole~\termhole~\termhole~\termhole~\termhole~\termhole~\termhole \defeq \unittt \\
    & \fname{production\_success$_=$}~\termhole~\termhole~\termhole~\termhole~\termhole~\termhole~\termhole~\termhole~\termhole \defeq \unittt \\
    & \fname{production\_failure$_<$}~\termhole~\termhole~\termhole~\termhole~\termhole~\termhole \defeq \unittt \\
    & \fname{production\_failure$_=$}~\termhole~\termhole~\termhole~\termhole~\termhole~\termhole \defeq \unittt \\
    & \fname{production\_failure$_{\not\in}$}~\termhole~\termhole~\termhole~\termhole~\termhole~\termhole \defeq \unittt
  \end{align*}}
  To instantiate our parser so that it returns \typeoption{\!\!\indname{ParseTree}} (rather, the dependently typed flavor, \indname{ParseTreeOf}), we take advantage of the isomorphism $\typesum{T}{\Unit} \cong \typeoption{T}$.  We show only the \fname{success} instantiations, as the \fname{failure} ones are identical with the Boolean recognizer.  For readability of the code, we write schematic natural-deduction proof trees inline.
  \begin{align*}
    & \fname{T$_{\fname{success}}$}~~\termhole~~\termhole~~\left(\parsetreetype{\farg{X}}{\farg{s}}\right) \defeq \parsetreetype{\farg{X}}{\farg{s}} \\
    \\
    & \fname{terminal\_success}~~\termhole~~\termhole~~\farg{ch} \defeq (\terminal{\farg{ch}}) \\
    & \fname{nil\_success}~~\termhole~~\termhole \defeq \overline{\str{}\in\epsilon} \\
    & \fname{cons\_success}~~\termhole~~\termhole~~\farg{it}~~\farg{its}~~\farg{s$_1$}~~\farg{s$_2$}~~\termhole~~\farg{d$_1$}~~\farg{d$_2$} \defeq \frac{\frac{\farg{d$_1$}}{\farg{s$_1$} \in \farg{it}}\qquad \frac{\farg{d$_2$}}{\farg{s$_2$} \in \farg{its}}}{\strcat{\farg{s$_1$}}{\farg{s$_2$}} \in \cons{\farg{it}}{\farg{its}}} \\
    & \fname{production\_success$_<$}~~\termhole~~\termhole~~\farg{it}~~\farg{nt}~~\farg{s}~~\termhole~~\farg{p}~~\farg{d} \defeq \frac{\frac{\farg{d}}{\farg{s} \in \farg{its}}}{\farg{s} \in \farg{nt}}{\text{\tiny\space(\farg{p})}} \\
    & \fname{production\_success$_=$}~~\termhole~~\termhole~~\farg{it}~~\farg{nt}~~\farg{s}~~\termhole~~\farg{p}~~\farg{d} \defeq \frac{\frac{\farg{d}}{\farg{s} \in \farg{its}}}{\farg{s} \in \farg{nt}}{\text{\tiny\space(\farg{p})}}
  \end{align*}
  What remains is to instantiate the parser in such a way that proving completeness is trivial.  The simpler of our two tasks is to show that when the parser fails, no minimal parse tree exists.  Hence we instantiate the types as follows, where $\False$ is the empty type (equivalently, the false proposition).
  \begin{align*}
    & \fname{T$_{\fname{success}}$}~~\termhole~~\termhole~~\termhole \defeq \Unit \\
    & \fname{T$_{\fname{failure}}$}~~\farg{s$_0$}~~\farg{unseen}~~\left(\parsetreetype{\farg{X}}{\farg{s}}\right) \defeq \left(\minparsetreetype{\farg{s$_0$}}{\farg{unseen}}{\farg{X}}{\farg{s}}\right) \typeto \False
  \end{align*}
  Using \Lightning{} to denote deriving a contradiction, we can unenlighteningly instantiate the arguments as
  \begin{align*}
    & \fname{terminal\_success}~~\termhole~~\termhole~~\termhole \defeq \unittt \\
    & \fname{terminal\_failure}~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole \defeq \text{\Lightning} \\
    & \fname{nil\_success}~~\termhole~~\termhole \defeq \unittt \\
    & \fname{nil\_failure}~~\termhole~~\termhole~~\termhole~~\termhole \defeq \text{\Lightning} \\
    & \fname{cons\_success}~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole \defeq \unittt \\
    & \fname{cons\_failure}~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole \defeq \text{\Lightning} \\
    & \fname{production\_success$_<$}~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole \defeq \unittt \\
    & \fname{production\_success$_=$}~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole \defeq \unittt \\
    & \fname{production\_failure$_<$}~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole \defeq \text{\Lightning} \\
    & \fname{production\_failure$_=$}~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole \defeq \text{\Lightning} \\
    & \fname{production\_failure$_{\not\in}$}~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole~~\termhole \defeq \text{\Lightning}
  \end{align*}
  A careful inspection of the proofy arguments to each \fname{failure} case will reveal that there is enough evidence to derive the appropriate contradiction.  For example, the $\farg{s}\neq\str{}$ hypothesis of \fname{nil\_failure} contradicts the equalities implied by the type signature of \fname{min\_parse$_{\nil}$}, and the use of \nil\space contradicts the equality implied by the use of \cons{\farg{it}}{\farg{its}} in the type signature of \fname{min\_parse$_{\nil}$}.  Similarly, the $\farg{s}\neq\str{\farg{ch}}$ hypothesis of \fname{terminal\_failure} contradicts the equality implied by the usage of the single identifier \farg{ch} in two different places in the type signature of \fname{min\_parse$_{\terminal{\farg{ch}}}$}.

  \subsection{Parsing Parses}
    We finally come to the most twisty part of the parser: parsing parse trees.  Recall that our parser definition is polymorphic in a choice of \String{} type.  We proceed with the straw-man solution of literally passing in parse trees as strings to be parsed, such that parsing generates \emph{minimal} parse trees, as introduced in \autoref{sec:min:conceptual-intro} and defined formally in \autoref{sec:min:formal-definition}.  Intuitively, we run a top-down traversal of the tree, pausing at each node before descending to its children.  During that pause, we \emph{eliminate one level of wastefulness}: if the parse tree is proving $\parsetreetype{\farg{X}}{\farg{s}}$, we look for any subtrees also proving $\parsetreetype{\farg{X}}{\farg{s}}$.  If we find any, we replace the original tree with \emph{the smallest duplicative subtree}.  If we do not find any, we leave the tree unchanged.  In either case, we then descend into ``parsing'' each subtree.

    We define a function \fname{deloop} to perform the one step of eliminating waste:
    \begin{align*}
      \fname{deloop} & \oftypesep \indname{ParseTreeOf}~\farg{nt}~\farg{s} \typeto \indname{ParseTreeOf}~\farg{nt}~\farg{s}
    \end{align*}
    This transformation is straightforward to define by structural recursion.

    To implement all of the generic parameters of the parser, we must actually augment the result type of \fname{deloop} with stronger types.  Define the predicate $\fname{Unloopy}(t)$ on parse trees $t$ to mean that, where the root node of $t$ proves $\parsetreetype{\farg{nt}}{\farg{s}}$, for every subtree proving $\parsetreetype{\farg{nt$'$}}{\farg{s}}$ (same string, possibly different nonterminal), (1) \farg{nt$'$} is in the set of allowed nonterminals, \farg{unseen}, associated to the overall tree with dependent types, and (2) if this is not the root node, then $\farg{nt$'$} \neq \farg{nt}$.

    We augment the return type of \fname{deloop}, writing:
    $$\{t : \indname{ParseTreeOf}~\farg{nt}~\farg{s} \; | \; \fname{Unloopy}(t)\}.$$
    We instantiate the generic ``string'' type parameter of the general parser with this type family, so that, in implementing the different parameters to pass to the parser, we have the property available to us.

    Another key ingredient is the ``string'' splitter, which naturally breaks a parse tree into its child trees.  We define it like so:
    \begin{align*}
    & \fname{split}~\termhole~\termhole~\left(\parsetreetype{\cons{\farg{it}}{\farg{its}}}{\farg{s}}\right) \defeq \\
    & \quad \caseof{\fname{parse\_tree\_data}~~\farg{s}} \\
    & \quad \acase{\frac{\frac{\farg{p$_1$}}{\farg{s$_1$}\in \farg{it}}\qquad \frac{\farg{p$_2$}}{\farg{s$_2$}\in \farg{its}}}{\strcat{\farg{s$_1$}}{\farg{s$_2$}} \in \cons{\farg{it}}{\farg{its}}}}
    {\valuelistm{\left(\fname{deloop}~\farg{p$_1$}, \fname{deloop}~\farg{p$_2$}\right)}} \\
    & \quad \acase{\termhole}{\text{\Lightning}} \\
    & \fname{split}~\termhole~\termhole~\termhole \defeq \nil
    \end{align*}
    Note that we use \farg{it} and \farg{its} nonlinearly; the pattern only binds if its \farg{it} and \farg{its} match those passed as arguments to \fname{split}.  We thus return a nonempty list only if the query is about a nonempty sequence of items.  Because we use dependent types to enforce the requirement that the parse tree associated with a string match the query we are considering, we can derive contradictions in the non-matching cases.

    This splitter satisfies two important properties.  First, it never returns the empty list on a parse tree whose list of productions is nonempty; call this property \emph{nonempty preservation}.  Second, it preserves \fname{Unloopy}.  We use both facts in the other parameters to the generic parser (and we leave their proofs as exercises for the reader---Coq solutions may be found in our source code).

    Now recall that our general parser always returns a type of the form $\typesum{\fname{T$_{\fname{success}}$}}{\fname{T$_{\fname{failure}}$}}$, for some $\fname{T$_{\fname{success}}$}$ and $\fname{T$_{\fname{failure}}$}$.  We want our tree minimizer to return just the type of minimal trees.  However, we can take advantage of the type isomorphism $\typesum{T}{\False} \cong T$ and instantiate $\fname{T$_{\fname{failure}}$}$ with $\False$, the uninhabited type; and then apply a simple fix-up wrapper on top.  Thus, we instantiate the general parser like so:
    \begin{align*}
      & \fname{T$_{\fname{success}}$}~~\farg{s$_0$}~~\farg{unseen}~~\left(\oftype{\farg{d}}{\parsetreetype{\farg{X}}{\farg{s}}}\right) \defeq \minparsetreetype{\farg{s$_0$}}{\farg{unseen}}{\farg{X}}{\farg{s}} \\
      & \fname{T$_{\fname{failure}}$}~~\termhole~~\termhole~~\termhole \defeq \False
    \end{align*}

    The \fname{success} cases are instantiated in an essentially identical way to the instantiation we used to get \typeoption{\indname{ParseTree}}.  The \fname{terminal\_failure} and \fname{nil\_failure} cases provide enough information ($\farg{s}\neq\str{\farg{ch}}$ and $\farg{s}\neq\str{}$, respectively) to derive \False{} from the existence of the appropriately typed parse tree.  In the \fname{cons\_failure} case, we make use of the splitter's \emph{nonempty preservation} behavior, after which all that remains is \typesum{\False}{\False}~\typeto~\False, which is trivial.  In the \fname{production\_failure$_<$} and \fname{production\_failure$_=$} cases, it is sufficient to note that every nonterminal is mapped by some production to some sequence of items.  Finally, to instantiate the \fname{production\_failure$_{\not\in}$} case, we need to appeal to the \fname{Unloopy}-ness of the tree to deduce that $\farg{nt}\in \farg{unseen}$.  Then we can derive \False{} from the hypothesis that $\farg{nt}\not\in\farg{unseen}$, and we are done.

    We instantiate the general parser with an input type that requires \fname{Unloopy}, so our final tree minimizer is really the composition of the instantiated parser with \fname{deloop}, ensuring that invariant as we kick off the recursion.

  \subsection{Example} \label{sec:example-min-execution}

\label{sec:parser-impl}
\begin{figure*}\caption{Pseudo-Implementation of our parser.  We take the convention that dependent indices to functions (e.g., \fname{unseen}) are implicit.}\label{fig:parser-impl}
  \begin{align*}
    & \fname{parse}~~\farg{nt}~~\farg{s} \defeq \fname{parse$'$}~~(\farg{s$_0$}\defeq\farg{s})~~(\farg{unseen}\defeq\fname{unseen$_0$})~~(\parsetreetype{\farg{nt}}{\farg{s}}) \\
    \\
    & \fname{parse$'$}~~(\parsetreetype{\terminal{\farg{ch}}}{\str{\farg{ch}}}) \defeq \inl{~\fname{terminal\_success}} \\
    & \fname{parse$'$}~~(\parsetreetype{\terminal{\farg{ch}}}{\termhole}) \defeq \inrp{\fname{terminal\_failure}~\text{\Lightning{}}} \\
    & \fname{parse$'$}~~(\parsetreetype{\epsilon}{\str{}}) \defeq \inl{~\fname{nil\_success}} \\
    & \fname{parse$'$}~~(\parsetreetype{\epsilon}{\termhole}) \defeq \inrp{\fname{nil\_failure}~\text{\Lightning{}}} \\
    & \fname{parse$'$}~~(\parsetreetype{\cons{\farg{it}}{\farg{its}}}{\farg{s}}) \defeq \\
    & \qquad\caseof{\fname{any\_parse}~~\farg{s}~~\farg{it}~~\farg{its}~~\left(\fname{split}~~(\parsetreetype{\cons{\farg{it}}{\farg{its}}}{\farg{s}})\right)} \\
    & \qquad\acase{\inl{\farg{ret}}}{\inl{\farg{ret}}} \\
    & \qquad\acase{\inr{\farg{ret}}}{\inrp{\fname{cons\_failure}~~\termhole~~\farg{ret}}} \\
    & \fname{parse$'$}~~(\parsetreetype{\farg{nt}}{\farg{s}}) \defeq \\
    & \qquad \cif\farg{s} < \farg{s$_0$} \\
    & \qquad \cthen\cif\left(\fname{parse$'$}~~(\farg{s$_0$}\defeq\farg{s})~~(\farg{unseen}\defeq\fname{unseen$_0$})~~(\parsetreetype{\farg{its}}{\farg{s}})\right)~~\text{succeeds returning}~~\farg{d} \\
    & \qquad\cifindent\cifindent\qquad\qquad\text{for any production \farg{p} mapping \farg{nt} to \farg{its}}  \\
    & \qquad\cifindent\cthen\inlp{\fname{production\_success$_<$}~~\termhole~~\farg{p}~~\farg{d}} \\
    & \qquad\cifindent\celse\inrp{\fname{production\_failure$_<$}~~\termhole~~\termhole} \\
    & \qquad\celse\cif\farg{nt}\in\farg{unseen} \\
    & \qquad\cifindent\cthen\cif\left(\fname{parse$'$}~~(\farg{unseen}\defeq\fname{unseen} - \{\farg{nt}\})~~(\parsetreetype{\farg{its}}{\farg{s}})\right)~~\text{succeeds returning}~~\farg{d} \\
    & \qquad\cifindent\cifindent\cifindent\qquad\qquad\text{for any production \farg{p} mapping \farg{nt} to \farg{its}}  \\
    & \qquad\cifindent\cifindent\cthen\inlp{\fname{production\_success$_=$}~~\termhole~~\farg{p}~~\farg{d}} \\
    & \qquad\cifindent\cifindent\celse\inrp{\fname{production\_failure$_=$}~~\termhole~~\termhole} \\
    & \qquad\cifindent\celse\inrp{\fname{production\_failure$_{\not\in}$}~~\termhole~~\termhole} \\
    \\
    & \fname{any\_parse}~~\farg{s}~~\farg{it}~~\farg{its}~~\nil \defeq \inrp{\afun{\oftype{\termhole}{(\termhole\in\nil)}}{\text{\Lightning}}} \\
    & \fname{any\_parse}~~\farg{s}~~\farg{it}~~\farg{its}~~\left(\cons{\farg{x}}{\farg{xs}}\right) \defeq \\
    & \qquad\caseof{\fname{parse$'$}~~(\parsetreetype{\farg{it}}{\fname{take}\ensuremath{{}_{\farg{x}}}~~\farg{s}})
        \textbf{,}~~\fname{parse$'$}~~(\parsetreetype{\farg{its}}{\fname{drop}\ensuremath{{}_{\farg{x}}}~~\farg{s}})
        \textbf{,}~~\fname{any\_parse}~~\farg{s}~~\farg{it}~~\farg{its}~~\farg{xs}} \\
    & \qquad\acase{\inl{\farg{ret$_1$}}
        \textbf{,}~~\inl{\farg{ret$_2$}}
        \textbf{,}~~\aswidthof{\termhole}{\inl{\farg{ret$'$}}}}
        {\inlp{\fname{cons\_success}~~\termhole~~\farg{ret$_1$}~~\farg{ret$_2$}}} \\
    & \qquad\acase{\aswidthof{\termhole}{\inr{\farg{ret$_1$}}}
            \textbf{,}~~\aswidthof{\termhole}{\inr{\farg{ret$_2$}}}
            \textbf{,}~~\inl{\farg{ret$'$}}}
            {\inl{\farg{ret$'$}}} \\
    & \qquad\acase{\aswidthof{\farg{ret$_1$}}{\inr{\farg{ret$_1$}}}
        \textbf{,}~~\aswidthof{\farg{ret$_2$}}{\inr{\farg{ret$_2$}}}
        \textbf{,}~~\inr{\farg{ret$'$}}}
        {\inr{\termhole}}
  \end{align*}
  where the hole on the last line constructs a proof of
  $$\forall~\farg{x$'$} \in \left(\cons{\farg{x}}{\farg{xs}}\right),~~\typesum{\fname{T$_{\fname{failure}}$}~~\termhole~~\termhole~~(\parsetreetype{\farg{it}}{\fname{take}_{\farg{x$'$}}~~\farg{s}})}{\fname{T$_{\fname{failure}}$}~~\termhole~~\termhole~~(\parsetreetype{\farg{its}}{\fname{drop}_{\farg{x$'$}}~~\farg{s}})}$$
  by using \farg{ret$'$} directly when $\farg{x$'$}\in \farg{xs}$, and using whichever one of \farg{ret$_1$} and \farg{ret$_2$} is on the right when $\farg{x$'$} = \farg{x}$.  While straightforward, the use of sum types makes it painfully verbose without actually adding any insight; we prefer to elide the actual term.
  %% \begin{align*}
  %%   & \qquad\acase{\inr{\farg{ret$_1$}}
  %%     \textbf{,}~~\aswidthof{\termhole}{\inr{\farg{ret$_2$}}}
  %%     \textbf{,}~~\inr{\farg{ret$'$}}}
  %%       {\inrp{\afun{\left((\farg{s$'_1$}, \farg{s$'_2$}) \in \left(\cons{(\farg{s$_1$}, \farg{s$_2$})}{\farg{xs}}\right)\right)}{\fname{helper}~~(\farg{s$'_1$}, \farg{s$'_2$})~~(\farg{s$_1$}, \farg{s$_2$})~~\farg{xs}~~\left(\inl{\farg{ret$_1$}}\right)~~\farg{ret$'$}}}} \\
  %%   & \qquad\acase{\aswidthof{\termhole}{\inr{\farg{ret$_1$}}}
  %%     \textbf{,}~~\inr{\farg{ret$_2$}}
  %%     \textbf{,}~~\inr{\farg{ret$'$}}}
  %%       {\inrp{\afun{\left((\farg{s$'_1$}, \farg{s$'_2$}) \in \left(\cons{(\farg{s$_1$}, \farg{s$_2$})}{\farg{xs}}\right)\right)}{\fname{helper}~~(\farg{s$'_1$}, \farg{s$'_2$})~~(\farg{s$_1$}, \farg{s$_2$})~~\farg{xs}~~\left(\inr{\farg{ret$_2$}}\right)~~\farg{ret$'$}}}} \\
  %%   \\
  %%   & \fname{helper}~~\farg{x$'$}~~\farg{x}~~\farg{xs}~~\farg{ret}~~\farg{ret'} \defeq \textbf{if}~~\farg{x} \testeq \farg{x$'$}~~\textbf{then}~~\farg{ret}~~\textbf{else}~~\farg{ret$'$}
  %% \end{align*}}
\end{figure*}

    In \autoref{sec:loopy-grammar-example}, we defined an ambiguous grammar for \regex{(ab)$^*$} which led our naive parser to diverge.  We will walk through the minimization of the following parse tree of \str{abab} into this grammar.  For reference, \autoref{fig:parser-impl} contains the fully general implementation of our parser, modulo type signatures.

    For reasons of space, define $\overline{T}$ to be the parse tree
    \[
      \AxiomC{} \UnaryInfC{\str{} $\in$ $\epsilon$}
      \UnaryInfC{\str{} $\in$ \regex{(ab)$^*$}}
      %
      \AxiomC{}\UnaryInfC{\str{a} $\in$ \terminal{a}}
      \AxiomC{}\UnaryInfC{\str{b} $\in$ \terminal{b}}
      \BinaryInfC{\llstrcat{\str{a}}{\str{b}} $\in$ \regex{(ab)$^*$}}
      %
      \UnaryInfC{\str{ab} $\in$ \regex{(ab)$^*$}}
      %
      \RightLabel{\scriptsize(\regex{(ab)$^*$(ab)$^*$})}
      \BinaryInfC{\llstrcat{\str{}}{\str{ab}} $\in$ \regex{(ab)$^*$}}
    \DisplayProof
    \]
    Then we consider minimizing the parse tree:
    \[
      \AxiomC{}
      \UnaryInfC{$T$}
      \UnaryInfC{\str{ab} $\in$ \regex{(ab)$^*$}}
      \AxiomC{}
      \UnaryInfC{$T$}
      \UnaryInfC{\str{ab} $\in$ \regex{(ab)$^*$}}
      \RightLabel{\scriptsize(\regex{(ab)$^*$(ab)$^*$})}
      \BinaryInfC{\llstrcat{\str{ab}}{\str{ab}} $\in$ \regex{(ab)$^*$}}
      \UnaryInfC{\str{abab} $\in$ \regex{(ab)$^*$}}
    \DisplayProof
    \]
    Letting $\overline{T'_m}$ denote the same tree as $\overline{T'}$, but constructed as a \indname{MinParseTree} rather than a \indname{ParseTree},
%    \begin{center}
%      \AxiomC{}\UnaryInfC{\str{a} $\in$ \terminal{a}}
%      \AxiomC{}\UnaryInfC{\str{b} $\in$ \terminal{b}}
%      %\RightLabel{\scriptsize\minparsetreeannot{\str{ab}}{\nil}}
%      \BinaryInfC{\llstrcat{\str{a}}{\str{b}} $\in$ \regex{(ab)$^*$}}
%    \DisplayProof
%    \end{center}
    the tree we will end up with is:
    \[
      \AxiomC{}\UnaryInfC{$T'_m$}
      \RightLabel{\scriptsize\minparsetreeannot{\str{ab}}{\valuelist{\regex{(ab)$^*$}}}}
      \UnaryInfC{\str{ab} $\in$ \regex{(ab)$^*$}}
      \AxiomC{}\UnaryInfC{$T'_m$}
      \RightLabel{\scriptsize\minparsetreeannot{\str{ab}}{\valuelist{\regex{(ab)$^*$}}}}
      \UnaryInfC{\str{ab} $\in$ \regex{(ab)$^*$}}
      \RightLabel{\scriptsize\minparsetreeannot{\str{abab}}{\nil}}
      \BinaryInfC{\llstrcat{\str{ab}}{\str{ab}} $\in$ \regex{(ab)$^*$}}
      \RightLabel{\scriptsize\minparsetreeannot{\str{abab}}{\valuelist{\regex{(ab)$^*$}}}}
      \UnaryInfC{\str{abab} $\in$ \regex{(ab)$^*$}}
    \DisplayProof
    \]

    To begin, we call \fname{parse}, passing in the entire tree as the string, and \regex{(ab)$^*$} as the nonterminal.  To transform the tree into one that satisfies \fname{Unloopy}, the first thing \fname{parse} does is call \fname{deloop} on our tree.  In this case, \fname{deloop} is a no-op; it promotes the deepest non-root nodes labeled with $(\str{abab}\in\regex{(ab)$^*$})$, of which there are none.

    We then take the following execution steps, starting with $\farg{unseen} \defeq \fname{unseen$_0$} \defeq \valuelist{\regex{(ab)$^*$}}$, the singleton list containing the only nonterminal, and $\farg{s$_0$} \defeq \str{abab}$.
    \begin{enumerate}
      \item
        We first ensure that we are not in an infinite loop.  We check if $\farg{s} < \farg{s$_0$}$ (it is not, for they are both equal to \str{abab}), and then check if our current nonterminal, \regex{(ab)$^*$}, is in \farg{unseen}.  Since the second check succeeds, we remove \regex{(ab)$^*$} from \farg{unseen}; calls made by this stack frame will pass \nil\space for \farg{unseen}.
      \item
        We may consider only the productions for which the parse tree associated to the string is well-typed; we will describe the headaches this seemingly innocuous simplification caused us in \autoref{sec:misordered-splitters}.  The only such production in this case is the one that lines up with the production used in the parse tree, labeled \regex{(ab)$^*$(ab)$^*$}.
      \item
        We invoke \fname{split} on our parse tree.
        \begin{enumerate}
          \item
            The \fname{split} that we defined then invokes \fname{deloop} on the two copies of the parse tree
            \[
              \AxiomC{}
              \UnaryInfC{$T$}
              \UnaryInfC{\str{ab} $\in$ \regex{(ab)$^*$}}
            \DisplayProof
            \]
            Since there are non-root nodes labeled with $(\str{ab}\in\regex{(ab)$^*$})$, the label of the root node, we promote the deepest one.  Letting $T'$ denote the tree
            \[
              \AxiomC{}\UnaryInfC{\str{a} $\in$ \terminal{a}}
              \AxiomC{}\UnaryInfC{\str{b} $\in$ \terminal{b}}
              \RightLabel{\scriptsize(\str{ab})}
              \BinaryInfC{\llstrcat{\str{a}}{\str{b}} $\in$ \regex{(ab)$^*$}}
            \DisplayProof
            \]
            the result of calling \fname{deloop} is the tree
            \[
              \AxiomC{}
              \UnaryInfC{$T'$}
              \UnaryInfC{\str{ab} $\in$ \regex{(ab)$^*$}}
            \DisplayProof
            \]

          \item The return of \fname{split} is thus the singleton list containing a single pair of two parse trees; each element of the pair is the parse tree for \str{ab} $\in$ \regex{(ab)$^*$} that was returned by \fname{deloop}.
        \end{enumerate}
      \item
        We invoke \fname{parse} on each of the items in the sequence of items associated to \regex{(ab)$^*$} via the rule (\regex{(ab)$^*$(ab)$^*$}).  The two items are identical, and their associated elements of the pair returned by \fname{split} are identical, so we only describe the execution once, on
        \[
          \AxiomC{}
          \UnaryInfC{$T'$}
          \UnaryInfC{\str{ab} $\in$ \regex{(ab)$^*$}}
        \DisplayProof
        \]

        \begin{enumerate}
          \item
            We first ensure that we are not in an infinite loop.  We check if $\farg{s} < \farg{s$_0$}$.  This check succeeds, for \str{ab} is shorter than \str{abab}.  We thus reset \farg{unseen} and \farg{s$_0$}; calls made by this stack frame will pass $\fname{unseen$_0$}\equiv \valuelist{\regex{(ab)$^*$}}$ for \farg{unseen}, and $\farg{s} \equiv \str{ab}$ for \farg{s$_0$}.
          \item
            We may again consider only the productions for which the parse tree associated to the string is well-typed.  The only such production in this case is the one that lines up with the production used in the parse tree $T'$, labeled (\str{ab}).
          \item
            We invoke \fname{split} on our parse tree.
            \begin{enumerate}
              \item
                The \fname{split} that we defined then invokes \fname{deloop} on the trees $\overline{\str{a}\in \terminal{a}}$ and $\overline{\str{b}\in \terminal{b}}$.  Since these trees have no non-root nodes (let alone non-root nodes sharing a label with the root), \fname{deloop} is a no-op.
              \item
                The return of \fname{split} is thus the singleton list containing a single pair of two parse trees; the first is the parse tree $\overline{\str{a}\in \terminal{a}}$, and the second is the parse tree $\overline{\str{b}\in \terminal{b}}$.
            \end{enumerate}
          \item
            We invoke \fname{parse} on each of the items in the sequence of items associated to \regex{(ab)$^*$} via the rule (\str{ab}).  Since both of these items are terminals, and the relevant equality check (that \str{a} is equal to \str{a}, and similarly for \str{b}) succeeds, \fname{parse} returns \fname{terminal\_success}.  We thus have the two \indname{MinParseTree}s: $\overline{\str{a}\in \terminal{a}}$ and $\overline{\str{b}\in \terminal{b}}$.
          \item
            We combine these using \fname{cons\_success} (and \fname{nil\_success}, to tie up the base case of the list).  We thus have the tree $\overline{T'_m}$.
          \item
            We apply \fname{production\_success$_<$} to this tree, and return the tree
            \[
              \AxiomC{}\UnaryInfC{$T'_m$}
              \RightLabel{\scriptsize\minparsetreeannot{\str{ab}}{\valuelist{\regex{(ab)$^*$}}}}
              \UnaryInfC{\str{ab} $\in$ \regex{(ab)$^*$}}
            \DisplayProof
            \]
        \end{enumerate}
      \item
        We now combine the two identical trees returned by \fname{parse} using \fname{cons\_success} (and \fname{nil\_success}, to tie up the base case of the list).  We thus have the tree
        \[
          \AxiomC{}\UnaryInfC{$T'_m$}
          \RightLabel{\scriptsize\minparsetreeannot{\str{ab}}{\valuelist{\regex{(ab)$^*$}}}}
          \UnaryInfC{\str{ab} $\in$ \regex{(ab)$^*$}}
          \AxiomC{}\UnaryInfC{$T'_m$}
          \RightLabel{\scriptsize\minparsetreeannot{\str{ab}}{\valuelist{\regex{(ab)$^*$}}}}
          \UnaryInfC{\str{ab} $\in$ \regex{(ab)$^*$}}
          \RightLabel{\scriptsize\minparsetreeannot{\str{abab}}{\nil}}
          \BinaryInfC{\llstrcat{\str{ab}}{\str{ab}} $\in$ \regex{(ab)$^*$}}
        \DisplayProof
        \]
      \item
        We apply \fname{production\_success$_=$} to this tree, and return the tree we claimed we would end up with,
        \[
          \AxiomC{}\UnaryInfC{$T'_m$}
          \RightLabel{\scriptsize\minparsetreeannot{\str{ab}}{\valuelist{\regex{(ab)$^*$}}}}
          \UnaryInfC{\str{ab} $\in$ \regex{(ab)$^*$}}
          \AxiomC{}\UnaryInfC{$T'_m$}
          \RightLabel{\scriptsize\minparsetreeannot{\str{ab}}{\valuelist{\regex{(ab)$^*$}}}}
          \UnaryInfC{\str{ab} $\in$ \regex{(ab)$^*$}}
          \RightLabel{\scriptsize\minparsetreeannot{\str{abab}}{\nil}}
          \BinaryInfC{\llstrcat{\str{ab}}{\str{ab}} $\in$ \regex{(ab)$^*$}}
          \RightLabel{\scriptsize\minparsetreeannot{\str{abab}}{\valuelist{\regex{(ab)$^*$}}}}
          \UnaryInfC{\str{abab} $\in$ \regex{(ab)$^*$}}
        \DisplayProof
        \]
    \end{enumerate}

  \subsection{Parametricity} \label{sec:parser-extensionality-theorem}
    Before we can combine different instantiations of this interface, we need to know that they behave similarly.  Inspection of the code, together with relational parametricity, validates assuming the following axiom, which should also be internally provable by straightforward induction (though we have not bothered to prove it).

    The \emph{parser extensionality axiom} states that, for any fixed instantiation of \fname{split}, and any arbitrary instantiations of the rest of the interface, giving rise to two different functions \fname{parse$_1$} and \fname{parse$_2$}, we have
    \begin{align*}
      & \forall~(\oftype{\farg{nt}}{\Nonterminal})~(\oftype{\farg{s}}{\String}), \\
      & \qquad\fname{bool\_of\_sum}~(\fname{parse$_1$}~\farg{nt}~\farg{s}) = \fname{bool\_of\_sum}~(\fname{parse$_2$}~\farg{nt}~\farg{s})
    \end{align*}
    where \fname{bool\_of\_sum} is, for any types $A$ and $B$, the function of type \typesum{\ensuremath{A}}{\ensuremath{B}}~\typeto~\Bool\space obtained by sending everything in the left component to \true, and everything in the right component to \false.

  \subsection{Putting It All Together}
    Now we have parsers returning the following types:
    \begin{align*}
      \fname{has\_parse} & \oftypesep \Nonterminal\typeto\String\typeto\Bool \\
      \fname{parse} & \oftypesep (\oftype{\farg{nt}}{\Nonterminal}) \typeto (\oftype{\farg{s}}{\String}) \\
      & \typeto \typeoptionp{\indname{ParseTreeOf}~\farg{nt}~\farg{s}} \\
      \fname{has\_no\_parse} & \oftypesep (\oftype{\farg{nt}}{\Nonterminal}) \typeto (\oftype{\farg{s}}{\String}) \\
      &  \typeto \typesum{\Unit}{\left(\indname{MinParseTreeOf}~\farg{nt}~\farg{s} \typeto \False\right)} \\
      \fname{min\_parse} & \oftypesep (\oftype{\farg{nt}}{\Nonterminal}) \typeto (\oftype{\farg{s}}{\String}) \\
      & \typeto \indname{ParseTreeOf}~\farg{nt}~\farg{s} \\
      & \typeto\indname{MinParseTreeOf}~\farg{nt}~\farg{s}
    \end{align*}
    Note that we have taken advantage of the isomorphism $\typesum{\Unit}{\Unit} \cong \Bool$ for \fname{has\_parse}, the isomorphism $\typesum{A}{\Unit} \cong \typeoption[~]{A}$ for \fname{parse}, and the isomorphism $\typesum{A}{\False} \cong A$ for \fname{min\_parse}.

    We can compose these functions to obtain our desired correct-by-construction parser:
    \begin{align*}
      & \fname{parse\_full} \oftypesep (\oftype{\farg{nt}}{\Nonterminal}) \typeto (\oftype{\farg{s}}{\String}) \\
      & \phantom{\fname{parse\_full} }\typeto \typesum{\indname{ParseTreeOf}~\farg{nt}~\farg{s}}{\left(\indname{ParseTreeOf}~\farg{nt}~\farg{s}\typeto\False\right)} \\
      & \fname{parse\_full}~\farg{nt}~\farg{s} \defeq \\
      & \quad \caseof{\fname{parse}~\farg{nt}~\farg{s}\textbf{,}~~\fname{has\_no\_parse}~\farg{nt}~\farg{s}} \\
      & \quad \acase{\Some{\farg{d}}\textbf{,}~~\aswidthof{\termhole}{\inr{\farg{nd}}}}{\inl{\farg{d}}} \\
      & \quad \acase{\aswidthof{\termhole}{\Some{\farg{d}}}\textbf{,}~~\inr{\farg{nd}}}{\inrp{\farg{nd}\circ\fname{min\_parse}}} \\
      & \quad \acase{\aswidthof{\termhole}{\Some{\farg{d}}}\textbf{,}~~\aswidthof{\termhole}{\inr{\farg{nd}}}}{\text{\Lightning{}}}
    \end{align*}
    In the final case, we derive a contradiction by applying the parser extensionality axiom, which says that \fname{parse} and \fname{has\_no\_parse} must agree on whether or not \farg{s} parses as \farg{nt}.
    
\section{Missteps, Insights, and Dependently Typed Lessons} \label{sec:lessons}
  We will now take a step back from the parser itself, and briefly talk about the process of coding it.  We encountered a few pitfalls that we think highlight some key aspects of dependently typed programming, and our successes suggest benefits to be reaped from using dependent types.

  \subsection{The Trouble of Choosing the Right Types}
    Although we began by attempting to write the type signature of our parser, we found that trying to write down the correct interface, without any code to implement it, was essentially intractable.  Giving your functions dependent types requires performing a nimble balancing act between being uselessly general on the one hand, and too overly specific on the other, all without falling from the highropes of well-typedness onto the unforgiving floor of type errors.

    We have found what we believe to be the worst sin the typechecker will let you get away with: having different levels of generality in different parts of your code base, which are supposed to interface with each other without a thoroughly vetted abstraction barrier between them.  Like setting your highropes at different tensions, every trip across the interface will be costly, and if the abstraction levels get too far away, recovering your balance will require Herculean effort.

    We eventually gave up on writing a dependently typed interface from the start, and decided instead to implement a simply typed Boolean recognizer, together with proofs of soundness and completeness.  Once we had in hand these proofs, and the data types required to carry them out, we found that it was mostly straightforward to write down the interface and refine our parser to inhabit its newly generalized type.

  \subsection{Misordered Splitters} \label{sec:misordered-splitters}
    One of our goals in this presentation was to hide most of the abstraction-level mismatch that ended up in our actual implementation, often through clever use of notation overloading.  One of the most significant mismatches we managed to overcome was the way to represent the set of productions.  In this paper, we left the type as an abstract mathematical set, allowing us to forgo concerns about ordering, quantification, and occasionally well-typedness.

    In our Coq implementation, we fixed the type of productions to be a list very early on, and paid the price when we implemented our parse-tree parser.  As mentioned in the execution of the example in \autoref{sec:example-min-execution}, we wanted to restrict our attention to certain productions, and rule out the other ones using dependent types.  This should be possible if we parameterize over not just a splitter, but a production-selector, and only require that our string type be well-typed for productions given by the production-selector.  However, the implementation that we currently have requires a well-typed string type for all productions; furthermore, it does not allow the order in which productions are considered to depend on the augmented string data.  We paid for this with the extra 300 lines of code we had to write to interleave two different splitters, so that we could handle the cases that we dismissed above as being ill-typed and therefore not necessary to consider.  That is, because our types were not formulated in a way that actually made these cases ill-typed, we had to deal with them, much to our displeasure.

  \subsection{Minimal Parse Trees vs.~Parallel Traces}
    Taking another step back, our biggest misstep actually came before we finished the completeness proof for our simply typed Boolean recognizer.

    When first constructing the type \indname{MinParseTree}, we thought of them genuinely as minimal parse trees (ones without a duplicate label in any single path).  After much head-banging, of knowledge that a theorem was obviously true, against proof goals that were obviously impossible, we discovered the single biggest insight---albeit a technical one---of the project.  The type of ``minimal parse trees'' we had originally formulated did not match the parse trees produced by our algorithm.  A careful examination of the algorithm execution in \autoref{sec:example-min-execution} should reveal the difference.\footnote{For readers wanting to skip that examination: the algorithm we described allows a label (\parsetreetype{\farg{nt}}{\farg{s}}) to appear one extra time along a path if, the first time it appears, its parent node's label, (\parsetreetype{\farg{nt$'$}}{\farg{s$'$}}), satisfies $\farg{s} < \farg{s$'$}$.  That is, whenever the string being parsed shrinks, the first nonterminal the shrunken string is parsed as may be duplicated once before shrinking the string again.}  Our insight, thus, was to conceptualize the data type as the type of traces of parallel executions of our particular parser, rather than as truly minimal parse trees.

    This may be an instance of a more general phenomenon present when programming with dependent types: subtle friction between what you think you are doing and what you are actually doing often manifests as impossible proof goals.