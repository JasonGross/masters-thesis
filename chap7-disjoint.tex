\chapter{disjoint items, parsing \#, +}
  \begin{itemize} \item  Goals
    \begin{itemize} \item  More exploration 
    \item  Demonstrate a slightly less obvious strategy that handles even more rules \end{itemize}
  \item  {}[Intro]
  \item  The splitting strategy: if the set of all characters in one item are disjoint from the set of possible first characters of the next item, then we can split at either the first character not in the first set, or at the first character that is in the second set.
    \begin{itemize} \item  For example, if the nonterminal "number" accepts {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, and the nonterminal "binop" accepts {+, -}, then we can either look for the first non-digit and split there, or we can look for the first + or -, and split there. \end{itemize}
  \item  Write down the grammars we want to handle.
  \item  We compute the sets reflectively.  Here is the algorithm.  Again, note the well-founded recursion.  <Coq code here>
  \item  We relate the computation to the parse trees by a few correctness criteria, similar to above.
    \begin{itemize} \item  Describe the structures and lemmas that go into it. \end{itemize}
  \item  This rule is not applied automatically, because we have this choice about what sets to look for.  In the future, we might pick whichever set is smaller, and do that (but perhaps we think one is more likely than the other?)  Instead we use \verb|setoid_rewrite|, with {}[reflexivity] to solve the side-conditions.
  \item  Example: Parse "1+2+3" \end{itemize}
  
\begin{verbatim}
Section IndexedImpl.
Typeclasses Opaque If_Then_Else.
  Lemma ComputationalSplitter'
  : FullySharpened (string_spec plus_expr_grammar).
  Proof.
    start honing parser using indexed representation.

    hone method "splits".
    {
      simplify parser splitter.
      setoid_rewrite refine_disjoint_search_for; [ | reflexivity.. ].
      simpl.
      finish honing parser method.
    }

    FullySharpenEachMethodWithoutDelegation.
    extract delegate-free implementation.
    simpl; higher_order_reflexivityT.
  Defined.

  Lemma ComputationalSplitter
  : FullySharpened (string_spec plus_expr_grammar).
  Proof.
    let impl := (eval simpl in (projT1 ComputationalSplitter')) in
    refine (existT _ impl _).
    abstract (exact (projT2 ComputationalSplitter')).
  Defined.

End IndexedImpl.
  
  
Lemma refine_disjoint_search_for {G : grammar Ascii.ascii} {str nt its}
      (Hvalid : grammar_rvalid G)
      (H_disjoint : disjoint ascii_beq
                             (possible_terminals_of G nt)
                             (possible_first_terminals_of_production G its))
: refine {splits : list nat
         | split_list_is_complete
             G str
             (NonTerminal nt)
             its splits}
         (ret [find_first_char_such_that str (fun ch => list_bin ascii_beq ch (possible_first_terminals_of_production G its))]).

Lemma refine_disjoint_search_for_not {G : grammar Ascii.ascii} {str nt its}
      (Hvalid : grammar_rvalid G)
      (H_disjoint : disjoint ascii_beq
                             (possible_terminals_of G nt)
                             (possible_first_terminals_of_production G its))
: refine {splits : list nat
         | split_list_is_complete
             G str
             (NonTerminal nt)
             its splits}
         (ret [find_first_char_such_that str (fun ch => negb (list_bin ascii_beq ch (possible_terminals_of G nt)))]).

\end{verbatim}